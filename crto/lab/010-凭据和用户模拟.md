# Credentials & User Impersonation

在SRV-1查看当前用户登录的session

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659357337265.png)

```ps```命令查看其他用户的进程

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659357364352.png)

# LogonPasswords

用mimikatz查看登录用户的密码信息，需要管理员权限

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659357435571.png)

# eKeys

用mimikatz查看encryption keys信息，需要管理员权限

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659357590470.png)

# Security Account Manager

导出本地sam的密码信息，这个测试的时候需要system权限

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659357912361.png)

# Domain Cached Credentials

导出内存中的哈希信息，这个测试的时候需要system权限

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659357980410.png)

# Make Token

制作令牌需要用户的明文密码

使用jking的账号密码制作一个访问令牌

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659358074280.png)

使用DA管理员nlamb的明文密码制作一个访问令牌

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659358203910.png)

# Process Injection

ps命令查看SRV-1上的进程，注入PID号为4800的进程，我们得到了一个新的shell

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659358545929.png)

# Token Impersonation

令牌模拟测试的时候需要在system下进行，同样使用PID号为4800的进程

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659358861805.png)

# SpawnAs

在WKSTN-1使用SpawnAs生成一个新进程3792

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659359527583.png)

# Pass the Hash

CS直接执行pth命令

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659359737874.png)

现在可以访问srv-2$

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659359761134.png)


也可以用mimikatz进行pth(需要system权限的beacon)

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659360052601.png)

注意上面执行完命令以后的PID是3896，使用```steal_token```模拟令牌
```
beacon> steal_token 3896
[+] Impersonated NT AUTHORITY\SYSTEM
```


# Overpass the Hash

OPTH，也叫票据传递

## 非system权限beacon

用rc4哈希制作tgt

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659360178308.png)

用aes256制作tgt

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659360353310.png)

用powershell根据上面生成的tgt（base rc4或者aes256）制作票据文件。文件名```jkingTGT.kirbi```

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659360533622.png)

使用```kerberos_ticket_use ```命令使用上面生成的```jkingTGT.kirbi```票据

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659360655062.png)

## system权限beacon

此权限下可以省略一步，不必制作```jkingTGT.kirbi```文件

1. 生成tgt

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659360814520.png)

记住，这里生成的ProcessID 是4744

使用steal_token 模拟令牌

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659360875068.png)


# Extracting Kerberos Tickets

使用Rubeus.exe 的```triage```列出当前系统上所有登录会话中的 Kerberos 票证，留意LUID列

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659361000781.png)

用Rubeus.exe 的```dump```命令从内存中提取我们需要的票据，这里我们选择LUID=0x1656b3的票据

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659361114221.png)


使用```createnetonly```命令创建一个登录会话并记下新的LUID和ProcessID

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659361297426.png)

注意新的LUID=0x16cf04,ProcessID=2160

使用```ptt```（pass the ticket）命令传递上面提取出来的票据

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659361446415.png)

传递完票据以后可以访问srv-2了

![img](https://github.com/maxzxc0110/hack-study/blob/main/img/1659361480402.png)