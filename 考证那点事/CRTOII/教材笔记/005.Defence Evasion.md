# Post-Exploitation Behaviours

Cobalt Strike's post-exploitation命令可以分为四大类

1. House-Keeping.  设置一个配置选项，或者在UI做一些事情，但是不会让Beacon去执行task，如：clear, help & note
2. API Only. 这些命令使用windows API，如：cd, cp, ls, make_token, & ps.
3. Inline Execution. 这些命令以Beacon对象文件（BOF）的形式实现，在Beacon进程本身中执行。如：jump psexec/64/psh 和 remote-exec psexec/wmi
4. Fork and Run. 这些命令产生了一个临时进程，并且注入一个post-exploitation DLL，任何输出都通过一个命名的管道被捕获，如：execute-assembly, powerpick 和 mimikatz


关于哪个命令属于哪个类别的文档：
[Beacon Command Behavior and OPSEC Considerations](https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/appendix-a_beacon-opsec-considerations.htm)


# SpawnTo

使用SpawnTo命令默认会在当前进程下产生一个rundll32子进程，这通常是被AV产品严密监视的，极容易被发现

1683447596204.jpg

1683447617015.jpg


改进方法：在spawnto命令后面加上一个二进制文件，如：
```
spawnto x64 %windir%\sysnative\notepad.exe
```

1683447656045.jpg

如果希望在 C2配置文件中设置缺省衍生文件，可以在 post-ex 块中这样做

```
post-ex {
    set spawnto_x86 "%windir%\\syswow64\\notepad.exe";
    set spawnto_x64 "%windir%\\sysnative\\notepad.exe";
}
```


# PPID Spoofing

默认情况下，派生进程是作为调用方的子进程产生的（参考上一节）

PPID Spoofing技术可以指定派生的进程的父进程，比如派生在 explorer.exe 下，原理是使用```CreateProcess ```API 可以指定目标的父ID

假设explorer.exe现在的pid是2704，执行命令：

```
ppid 2704
```

现在运行 shell ping 命令就会在explorer.exe下产生一个进程

1683448502501.jpg

如果要将 PPID 重置回 Beacon 进程，使用不带参数的 PPID 命令

```
beacon> ppid
[*] Tasked beacon to use itself as parent process
```


# Network Connections

在 ```Sysmon``` 监视器中，Beacon 的每次 check-in 都会生成一个新事件

这本身并没有什么神奇的绕过方法--作为操作者，你应该考虑你的主机进程进行网络连接是否有意义。 HTTP信标将进行HTTP/S连接，TCP信标进行TCP连接，SMB信标进行命名的管道连接。(There are no magic bypasses to this per se - as the operator, you should consider whether or not it makes sense for your host process to be making network connections.  An HTTP Beacon will make HTTP/S connections, the TCP Beacon TCP connections and the SMB Beacon named pipe connections.)


# Command Line Spoofing

进程可以用命令行参数启动:

```
C:\>notepad C:\Windows\System32\WindowsCodecsRaw.txt
```

日志工具和流程检查工具可以读取并记录这些参数，因为它们存储在流程本身的流程环境块(Process Environment Block，PEB)中

1683449861256.jpg

多数情况下我们希望隐藏我们真实的参数，可以通过以下4个步骤实现：
1. Create a process with "fake" arguments (these are the arguments you want to get logged) in a suspended state.（在suspended状态下创建一个带有“假”参数的进程）
2. Reach into the PEB and find the RTL_USER_PROCESS_PARAMETERS.（进入PEB，找到 RTL_USER_PROCESS_PARAMETERS）
3. Overwrite the command line arguments in this structure with the actual arguments you want executed.（用你想执行的实际参数覆盖这个结构中的命令行参数）
4. Resume the process.  When the process resumes, it executes the new arguments.（恢复进程。 当进程恢复时，它将执行新的参数）


在Cobalt Strike中使用```argue ```命令实现上面逻辑


首先是一个普通命令：
```
beacon> shell whoami /groups
```

将会被Sysmon 记录为：
```
Process Create:
ProcessId: 5096
Image: C:\Windows\System32\cmd.exe
CommandLine: C:\Windows\system32\cmd.exe /C whoami /groups
```

在CS中使用```argue ```,然后依然执行上面命令

```
beacon> argue C:\Windows\system32\cmd.exe /c ping 127.0.0.1 -n 10
[*] Tasked beacon to spoof 'C:\Windows\system32\cmd.exe' as '/c ping 127.0.0.1 -n 10'

beacon> shell whoami /groups
```

Sysmon 现在记录
```
Process Create:
ProcessId: 2588
Image: C:\Windows\System32\cmd.exe
CommandLine: C:\Windows\system32\cmd.exe /c ping 127.0.0.1 -n 10
```

> 命令行欺骗不是银弹，因为在这种情况下，whoami.exe的进程创建事件仍然被创建。 当运行不产生额外进程的命令时，这种技术要有效得多。(Command Line spoofing is not a silver bullet, as in this case a process creation event for whoami.exe was still created.  The technique is much more effective when running commands that don't spawn additional processes.)


# Session Prepping
1. 是什么？

Session Prepping是一个术语，描述如何为session做"准备",这是拿到initial Beacon或者横向移动后的一个重要步骤

2. 为什么？

使得我们的Beacon更加合理，不容易被发现，更加具有隐秘性

3. 怎么用？

一个思路是，找到 Edge、 IE 或 Chrome 的运行实例，然后向其注入一个 Beacon 有效载荷

如果找不到实例，则生成一个

一旦建立了Beacon ，使用spawnto 命令任何浏览器二进制， 保持PPID设置为Beacon进程

理由：

1. Browsers make outbound HTTP/S connections by design.
2. Edge, IE and Chrome are the most popular (you could include Firefox as well).
3. Browsers legitimately spawn new child processes per tab.

> Send a weaponised Word document in a phishing email that will locate a running instance of Edge, IE or Chrome, then inject a Beacon payload into it.  If an instance is not found, spawn one.  Once the Beacon has landed, set the spawnto to whichever browser binary we landed in (or spawned).  Keep the PPID set to the Beacon process.



对于横向移动：

jump winrm64 会在PowerShell 进程下

jump psexec64 会在rundll32 进程下


rundll32.dll是这里的一个主要例外，因为它在会话ID 0中运行，但没有PPID到一个现有的服务可执行文件。 无论我们使用的是哪种SPA，这都是真实的，因为这只是Cobalt Strike的psexec实现方式的本质。 服务和服务可执行文件在执行后被清理和删除，这使得承载有效载荷的进程处于这种无主状态。 我们不想继续在这个信标中操作，所以我们应该在这个主机上执行任何退出后的操作之前准备好这个会话。（rundll32.dll is a major outlier here because it's running in Session ID 0, but not PPID'd to an existing service executable.  This would be true for whatever spawnto we were using, as this is just the nature of how Cobalt Strike's psexec implementation works.  The service and service executable are cleaned up and removed after execution, which leaves the process hosting the payload in this orphaned state.  We don't want to continue operating in this Beacon, so we should prep the session before performing any post-ex actions on this host.）


根据我们想要实现的目标，我们可以选择两条路径：

1. inject一个用户进程，或者explorer，代价是可能从高完整性的shell降级到中等完整性

```
inject 4628 x64 smb
```

所以接下来，我们需要退出SYSTEM会话，并从cbridges链接到作为amoss运行的会话。 我们可以保留PPID，因为进程是explorer的一个子节点，然后将spawnto设置为用户可能执行的东西。（So next, we need to exit the SYSTEM session and link to the session running as amoss from cbridges.  We can leave the PPID since it's ok for processes to be a child of explorer, and then set the spawnto to something the user might execute.）

2. 如果我们想要在会话0中维护我们的系统级访问。对我来说最有意义的策略是将自己隐藏为现有服务可执行文件的子文件
其中大部分是 Services.exe (the "Services and Controller app")的子服务，绝大多数默认 Windows 服务以 svchost.exe 运行。其中许多还将产生自己的子代，如 SearchApp.exe, taskhostw.exe, ctfmon.exe 等


这些核心 Windows 进程的“问题”在于它们受到保护，因此您不能随意打开它们的句柄，即使当前用户是system

```
beacon> getuid
[*] You are NT AUTHORITY\SYSTEM (admin)

beacon> inject 840 x64 smb
[-] could not open process 840: 5
[-] could not connect to pipe
```

所以一个可靠的方案是找到第三方服务，因为他们往往会有较低的保护水平。让我们以 Amazon SSM 代理为例来看一看

1683452738726.jpg


amazon-ssm-agent.exe 是 AmazonSSMAgent  服务的服务可执行文件

```
SERVICE_NAME: AmazonSSMAgent
        TYPE               : 10  WIN32_OWN_PROCESS
        START_TYPE         : 2   AUTO_START
        ERROR_CONTROL      : 1   NORMAL
        BINARY_PATH_NAME   : "C:\Program Files\Amazon\SSM\amazon-ssm-agent.exe"
        LOAD_ORDER_GROUP   :
        TAG                : 0
        DISPLAY_NAME       : Amazon SSM Agent
        DEPENDENCIES       :
```

此服务作为子代产生 ssm-agent-worker.exe。这可能是一个很好的选择——我们可以注入到代理进程中，并将衍生程序设置为 worker 可执行文件

```
beacon> inject 2796 x64 smb
[+] established link to child beacon: 10.10.120.75

beacon> spawnto x64 %ProgramFiles%\Amazon\SSM\ssm-agent-worker.exe
```

1683452807672.jpg

综上，具体使用哪些第三方服务要看实际情况，枚举主机服务查看。


# Image Load Events

```execute-assembly```命令，CS会做以下事情

1. Spawn a temporary process (whatever is configured as the spawnto binary).(生成一个临时进程)
2. Load the .NET CLR (Common Language Runtime) into that process.(将.NET CLR加载到该进程中)
3. Execute the given .NET assembly in memory of that process.(在该进程的内存中执行给定的.NET程序集)
4. Get the output and kill the process.(获得输出并杀死该进程。)


避免这种检测方式的一个方法是将 spawnto 设置为 .NET 程序集--Windows 上有很多默认存在的程序集。 找到它们的方法之一是在你自己的机器上运行Sysmon，寻找在正常使用下加载CLR的程序集。 图像加载事件也有助于追踪Mimikatz等功能，因为它可以加载各种处理加密的DLLs，以及与Windows凭证库的交互等。(One way to avoid this style of detection is to set the spawnto to a .NET assembly - there are plenty that exist on Windows by default.  One way to find them is to run Sysmon on your own machine and look for assemblies that are loading the CLR under normal use.  Image load events can also be helpful in tracking down capabilities such as Mimikatz, because it can load various DLLs that handle cryptography, and interactions with the Windows Credential Vault etc.)

# SMB Named Pipes Names

Beacon 主要通过四种方式使用 SMB 命名管道。

1. Retrieve output from fork and run commands such as execute-assembly and powerpick.（检索fork的输出并运行命令，如execute-assembly和powerpick）
2. Connect to Beacon's SSH agent (not something we use in the course).（连接到Beacon的SSH代理）
3. The SMB Beacon's named pipe stager (also not often used).（ SMB Beacon的命名的管道分拣器）
4. C2 comms in the SMB Beacon itself.（ 在SMB Beacon本身的C2通讯）

要改变post-ex命令中使用的管道名称，在post-ex块中使用set pipename指令。 这可以接受一个用逗号分隔的名称列表，并且可以包括#字符以实现一些随机化。
```
post-ex {
        set pipename "totally_not_beacon, legitPipe_##";
}
```