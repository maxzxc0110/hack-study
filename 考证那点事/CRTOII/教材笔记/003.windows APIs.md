# WinAPI

WindowsAPI 是 WindowsOS 中可用的一组编程接口

可以在多种语言中使用(我们将在 P/Invoke 中看到这一点)

WinAPI 的使用对于 Windows 上的攻击性操作实际上是必不可少的。这些 API 支持主机枚举、启动进程、进程注入、令牌操作等操作(The use of WinAPIs are practically essential for offensive operations on Windows.  Actions such as host enumeration, starting processes, process injection, token manipulation and more)

最常用的 WinAPI 集合是基础服务(kernel32.dll)和高级服务(addapi32.dll)

除了WinAPIs之外，还有Native APIs。 大多数本地API调用是在ntoskrnl.exe（Windows内核镜像）中实现的，并通过ntdll.dll暴露给用户模式。 这些API严格来说并不是为了从用户应用程序中直接调用，因此不像WinAPIs那样容易访问。 更高级别的WinAPIs实际上是在后台调用这些Native APIs。 例如，kernel32.dll的OpenProcess调用ntdll.dll的NtOpenProcess。

(In addition to the WinAPIs, there are the Native APIs.  Most of the Native API calls are implemented in ntoskrnl.exe (the Windows kernel image) and exposed to user mode via ntdll.dll.  These APIs are not strictly designed to be called directly from user applications, and as such are not as accessible as the WinAPIs.  The higher-level WinAPIs actually call these Native APIs in the background.  For example, OpenProcess in kernel32.dll calls NtOpenProcess in ntdll.dll.)


# MessageBox in C++

函数末尾带A的使用 ANSI 字符串，如：MessageBoxA

函数末尾带W的使用 Unicode，如：MessageBoxW 

一个C++弹窗例子

```
#include <iostream>
#include <Windows.h>

int main()
{
    MessageBox(NULL, L"My first API call", L"Hello World", 0);
    return 0;
}
```


# CreateProcess in C++

[CreateProcessW](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw)函数结构文档

一个C++创建进程例子
```
#include <iostream>
#include <Windows.h>

int main()
{
    STARTUPINFO si;
    si.cb = sizeof(si);
    ZeroMemory(&si, sizeof(si));

    PROCESS_INFORMATION pi;
    ZeroMemory(&pi, sizeof(pi));

    BOOL success = CreateProcess(
        L"C:\\Windows\\System32\\notepad.exe",
        NULL,
        0,
        0,
        FALSE,
        0,
        NULL,
        L"C:\\Windows\\System32",
        &si,
        &pi);

    if (success)
    {
        printf("Process created with PID: %d.\n", pi.dwProcessId);
        return 0;
    }
    else
    {
        printf("Failed to create process. Error code: %d.\n", GetLastError());
        return 1;
    }
}
```


# P/Invoke

平台调用（P/Invoke）允许我们从托管代码中访问非托管库中的结构和函数（Platform Invoke (P/Invoke) allows us to access structs and functions present in unmanaged libraries from our managed code.）


用C/C++编写的应用程序和库被编译成机器代码，是非托管代码的例子（pplications and libraries written in C/C++ compile to machine code, and are examples of unmanaged code）


非托管代码的缺点是程序员需要手动管理内存

相比之下，托管代码在CLR（即通用语言运行时）上运行。 像C#这样的语言被编译成中间语言（IL），然后CLR在运行时将其转换为机器代码。 CLR还处理垃圾收集和各种运行时检查等方面，因此被称为拖管代码

# MessageBox in C#

一个C#弹窗例子

**DllImport 告诉运行库它需要加载指定的非托管 DLL(The first step is to use the DllImport attribute to tell the runtime it needs to load the specified unmanaged DLL.)**

```
using System;
using System.Runtime.InteropServices;

namespace PInvoke
{
    internal class Program
    {
        [DllImport("user32.dll", CharSet = CharSet.Unicode)]
        static extern int MessageBoxW(IntPtr hWnd, string lpText, string lpCaption, uint uType);

        static void Main(string[] args)
        {
            MessageBoxW(IntPtr.Zero, "My first P/Invoke", "Hello World", 0);
        }
    }
}
```
