# WinAPI

WindowsAPI 是 WindowsOS 中可用的一组编程接口

可以在多种语言中使用(我们将在 P/Invoke 中看到这一点)

WinAPI 的使用对于 Windows 上的攻击性操作实际上是必不可少的。这些 API 支持主机枚举、启动进程、进程注入、令牌操作等操作(The use of WinAPIs are practically essential for offensive operations on Windows.  Actions such as host enumeration, starting processes, process injection, token manipulation and more)

最常用的 WinAPI 集合是基础服务(kernel32.dll)和高级服务(addapi32.dll)

除了WinAPIs之外，还有Native APIs。 大多数本地API调用是在ntoskrnl.exe（Windows内核镜像）中实现的，并通过ntdll.dll暴露给用户模式。 这些API严格来说并不是为了从用户应用程序中直接调用，因此不像WinAPIs那样容易访问。 更高级别的WinAPIs实际上是在后台调用这些Native APIs。 例如，kernel32.dll的OpenProcess调用ntdll.dll的NtOpenProcess。

(In addition to the WinAPIs, there are the Native APIs.  Most of the Native API calls are implemented in ntoskrnl.exe (the Windows kernel image) and exposed to user mode via ntdll.dll.  These APIs are not strictly designed to be called directly from user applications, and as such are not as accessible as the WinAPIs.  The higher-level WinAPIs actually call these Native APIs in the background.  For example, OpenProcess in kernel32.dll calls NtOpenProcess in ntdll.dll.)


# MessageBox in C++

函数末尾带A的使用 ANSI 字符串，如：MessageBoxA

函数末尾带W的使用 Unicode，如：MessageBoxW 

一个C++弹窗例子

```
#include <iostream>
#include <Windows.h>

int main()
{
    MessageBox(NULL, L"My first API call", L"Hello World", 0);
    return 0;
}
```


# CreateProcess in C++

[CreateProcessW](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw)函数结构文档

一个C++创建进程例子
```
#include <iostream>
#include <Windows.h>

int main()
{
    STARTUPINFO si;
    si.cb = sizeof(si);
    ZeroMemory(&si, sizeof(si));

    PROCESS_INFORMATION pi;
    ZeroMemory(&pi, sizeof(pi));

    BOOL success = CreateProcess(
        L"C:\\Windows\\System32\\notepad.exe",
        NULL,
        0,
        0,
        FALSE,
        0,
        NULL,
        L"C:\\Windows\\System32",
        &si,
        &pi);

    if (success)
    {
        printf("Process created with PID: %d.\n", pi.dwProcessId);
        return 0;
    }
    else
    {
        printf("Failed to create process. Error code: %d.\n", GetLastError());
        return 1;
    }
}
```


# P/Invoke

平台调用（P/Invoke）允许我们从托管代码中访问非托管库中的结构和函数（Platform Invoke (P/Invoke) allows us to access structs and functions present in unmanaged libraries from our managed code.）


用C/C++编写的应用程序和库被编译成机器代码，是非托管代码的例子（pplications and libraries written in C/C++ compile to machine code, and are examples of unmanaged code）


非托管代码的缺点是程序员需要手动管理内存

相比之下，托管代码在CLR（即通用语言运行时）上运行。 像C#这样的语言被编译成中间语言（IL），然后CLR在运行时将其转换为机器代码。 CLR还处理垃圾收集和各种运行时检查等方面，因此被称为拖管代码

# MessageBox in C#

一个C#弹窗例子

**DllImport 告诉运行库它需要加载指定的非托管 DLL(The first step is to use the DllImport attribute to tell the runtime it needs to load the specified unmanaged DLL.)**

```
using System;
using System.Runtime.InteropServices;

namespace PInvoke
{
    internal class Program
    {
        [DllImport("user32.dll", CharSet = CharSet.Unicode)]
        static extern int MessageBoxW(IntPtr hWnd, string lpText, string lpCaption, uint uType);

        static void Main(string[] args)
        {
            MessageBoxW(IntPtr.Zero, "My first P/Invoke", "Hello World", 0);
        }
    }
}
```

# Type Marshalling

"Marshalling"是当需要在托管代码和非托管代码之间进行交叉时转换数据类型的过程（"Marshalling" is the process of transforming a data type when it needs to cross between managed and unmanaged code. ）

MessageBoxW需要两个 Unicode (LPCWSTR)类型传参，从strings类型转换过来是：

1683338087221.jpg

[托管和非托管数据类型映射表](https://learn.microsoft.com/en-us/dotnet/framework/interop/marshalling-data-with-platform-invoke)


# CreateProcess in C#

关于 DllImport 属性需要注意：

> Setting SetLastError to true tells the runtime to capture the error code.  This allows the user to retrieve it using Marshal.GetLastWin32Error().(设置SetLastError为true，告诉运行时捕获错误代码。 这允许用户使用Marshal.GetLastWin32Error()来检索它。)

> Reading the API documentation, you will see that some parameters are passed in as pointers (e.g. &si in C++).  In these cases, we use the ref keyword.  For data marshalled out of the API call (e.g. for PROCESS_INFORMATION), we use the out keyword.(阅读API文档，你会发现有些参数是以指针形式传入的（例如C++中的&si）。 在这种情况下，我们使用 ref 关键字。 对于从API调用中调出的数据（例如PROCESS_INFORMATION），我们使用out关键字。)


一个C#创建进程例子
```
using System;
using System.Runtime.InteropServices;

namespace PInvoke
{
    internal class Program
    {
        [StructLayout(LayoutKind.Sequential)]
        public struct STARTUPINFO
        {
            public int cb;
            public IntPtr lpReserved;
            public IntPtr lpDesktop;
            public IntPtr lpTitle;
            public int dwX;
            public int dwY;
            public int dwXSize;
            public int dwYSize;
            public int dwXCountChars;
            public int dwYCountChars;
            public int dwFillAttribute;
            public int dwFlags;
            public short wShowWindow;
            public short cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public int dwProcessId;
            public int dwThreadId;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct SECURITY_ATTRIBUTES
        {
            public int nLength;
            public IntPtr lpSecurityDescriptor;
            public bool bInheritHandle;
        }

        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        static extern bool CreateProcessW(string lpApplicationName, string lpCommandLine, ref SECURITY_ATTRIBUTES lpProcessAttributes,
            ref SECURITY_ATTRIBUTES lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment,
            string lpCurrentDirectory, ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);

        static void Main(string[] args)
        {
            var si = new STARTUPINFO();
            si.cb = Marshal.SizeOf(si);
        
            var pa = new SECURITY_ATTRIBUTES();
            pa.nLength = Marshal.SizeOf(pa);
        
            var ta = new SECURITY_ATTRIBUTES();
            ta.nLength = Marshal.SizeOf(ta);
        
            var pi = new PROCESS_INFORMATION();
        
            var success = CreateProcessW(
                "C:\\Windows\\System32\\notepad.exe",
                null,
                ref pa,
                ref ta,
                false,
                0,
                IntPtr.Zero,
                "C:\\Windows\\System32",
                ref si,
                out pi);
        
            if (success)
                Console.WriteLine("Process created with PID: {0}.", pi.dwProcessId);
            else
                Console.WriteLine("Failed to create process. Error code: {0}.", Marshal.GetLastWin32Error());
        }
    }
}
```

# Ordinals

An ordinal is a number that identifies an exported function in a DLL - think of them as the Primary Key in a database table.  Each exported function has an associated ordinal which is unique in that DLL, and we can use these ordinals with DllImport. (序数是在 DLL 中标识导出函数的数字——可以将它们看作数据库表中的主键。每个导出的函数都有一个关联的序数，这个序数在 DLL 中是唯一的，我们可以在 DllImport 中使用这些序数。)

主要是为了bypass一些检测函数名的AV

要查找导出函数的序号，使用 PEview.exe 打开 DLL，找到 EXPORT Address Table 并滚动到要调用的导出函数。

1683339049530.jpg

原：
```
[DllImport("user32.dll", CharSet = CharSet.Unicode)]
static extern int MessageBoxW(IntPtr hWnd, string lpText, string lpCaption, uint uType);
```

替换成：
```
[DllImport("user32.dll", EntryPoint = "#2155", CharSet = CharSet.Unicode)]
static extern int TotallyLegitAPI(IntPtr hWnd, string lpText, string lpCaption, uint uType);
```

序数在不同的 Windows 版本中可能有所不同，所以请确保为目标版本使用了正确的序数


# MessageBox in VBA

在VBA中使用Declare 关键字导入需要的函数
```
Declare PtrSafe Function MessageBoxW Lib "user32.dll" (ByVal hWnd As LongPtr, ByVal lpText As String, ByVal lpCaption As String, ByVal uType As Integer) As Integer
```

使用,因为我们调用的是 unicode 版本，所以需要 StrConv 将字符串转换为适当的格式
```
Declare PtrSafe Function MessageBoxW Lib "user32.dll" (ByVal hWnd As LongPtr, ByVal lpText As String, ByVal lpCaption As String, ByVal uType As Integer) As Integer

Sub Test()
    Dim result As Integer
    result = MessageBoxW(0, StrConv("P/Invoke from MS Word!", vbUnicode), StrConv("Hello World", vbUnicode), 0)
End Sub
```


# CreateProcess in VBA

与 C # 一样，在调用 API 之前，我们必须在 VBA 中定义必要的结构。这可以通过 Type 声明来完成

一个VBA创建进程的例子

```
Declare PtrSafe Function CreateProcessW Lib "kernel32.dll" (ByVal lpApplicationName As String, ByVal lpCommandLine As String, ByVal lpProcessAttributes As LongPtr, ByVal lpThreadAttributes As LongPtr, ByVal bInheritHandles As Boolean, ByVal dwCreationFlags As Long, ByVal lpEnvironment As LongPtr, ByVal lpCurrentDirectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Boolean

Type STARTUPINFO
    cb As Long
    lpReserved As String
    lpDesktop As String
    lpTitle As String
    dwX As Long
    dwY As Long
    dwXSize As Long
    dwYSize As Long
    dwXCountChars As Long
    dwYCountChars As Long
    dwFillAttribute As Long
    dwFlags As Long
    wShowWindow As Integer
    cbReserved2 As Integer
    lpReserved2 As LongPtr
    hStdInput As LongPtr
    hStdOutput As LongPtr
    hStdError As LongPtr
End Type

Type PROCESS_INFORMATION
    hProcess As LongPtr
    hThread As LongPtr
    dwProcessId As Long
    dwThreadId As Long
End Type

Sub Test()
    Dim si As STARTUPINFO
    Dim pi As PROCESS_INFORMATION
    
    Dim nullStr As String
    
    Dim success As Boolean
    success = CreateProcessW(StrConv("C:\Windows\System32\notepad.exe", vbUnicode), nullStr, 0&, 0&, False, 0, 0&, nullStr, si, pi)
End Sub
```

# D/Invoke

[D/Invoke](https://github.com/TheWover/DInvoke)是一个开源的 C # 项目，旨在直接替代 P/Invoke

功能包括：

> Invoke unmanaged code without P/Invoke.(不用P/Invoke来调用非托管代码。)

> Manually map unmanaged PE's into memory and call their associated entry point or an exported function.(手动将非托管的PE映射到内存中，并调用其相关的入口点或导出的函数。)

> Generate syscall wrappers for native APIs.(为native APIs生成syscall包装器。)



为什么要避免 P/Invoke？

[pestudio](https://www.winitor.com/)可以检查已编译的.NET 程序集，并标识“可疑的” P/Invoke调用用法

如： OpenProcess、 VirtualAllocEx、 WriteProcessMemory 和 CreateRemoteThread

# MessageBox with D/Invoke

D/Invoke 不使用 DllImport，而是依赖于使用```UnmanagedFunctionPointer```属性修饰的委托

```
[UnmanagedFunctionPointer(CallingConvention.StdCall, CharSet = CharSet.Unicode)]
delegate int MessageBoxW(IntPtr hWnd, string lpText, string pCaption, uint uType);
```

一个 D/Invoke的MessageBox 例子

```
using System;
using System.Runtime.InteropServices;

using DInvoke.DynamicInvoke;

namespace ConsoleApp1
{
    internal class Program
    {
        [UnmanagedFunctionPointer(CallingConvention.StdCall, CharSet = CharSet.Unicode)]
        delegate int MessageBoxW(IntPtr hWnd, string lpText, string pCaption, uint uType);

        static void Main(string[] args)
        {
            var parameters = new object[] { IntPtr.Zero, "My first D/Invoke!", "Hello World", (uint)0 };
            Generic.DynamicAPIInvoke("user32.dll", "MessageBoxW", typeof(MessageBoxW), ref parameters);
        }
    }
}
```


另一种方法是使用 ```GetLibraryAddress```  和 ```GetDelegateForFunctionPointer```。如果需要多次调用相同的 API，这通常会更方便

```
static void Main(string[] args)
{
    var address = Generic.GetLibraryAddress("user32.dll", "MessageBoxW");
    var messageBoxW = (MessageBoxW) Marshal.GetDelegateForFunctionPointer(address, typeof(MessageBoxW));

    messageBoxW(IntPtr.Zero, "Box 1", "Box 1", 0);
    messageBoxW(IntPtr.Zero, "Box 2", "Box 2", 0);
}
```

D/Invoke 擅长的一件事是提供多种方法来实现相同的目标，这提供了很大的灵活性

另外，```GetLibraryAddress```,有一个重载方法（多态），它第二个接收的参数是函数的序号，这也同样是为了bypass一些记录静态签名的AV

```
var address = Generic.GetLibraryAddress("user32.dll", 2155);
```

