# Endpoint Detection and Response

端点检测和响应（EDR）是一个综合安全解决方案的名称，它将端点的实时监测（以及可能的其他日志遥测）与分析和响应能力相结合

EDR特定是：

1. Collect event data from managed endpoints.（从被管理的端点收集事件数据。）
2. Analyse the data to identify known threat patterns.（分析数据以识别已知的威胁模式。）
3. Where applicable, automatically respond to threats (such as blocking/containing) and raise alerts.（在适用的情况下，自动响应威胁（如阻止/遏制）并发出警报。）
4. Aid manual investigations by providing forensic and analysis capabilities.（通过提供取证和分析能力帮助人工调查。）


# Detecting the Bad

EDR agents主要监测Windows APIs的使用情况，例如进程注入以及其他C2的操作？

然而如何监控一台机器上每个正在运行的进程正在使用哪些API呢？

一个合乎逻辑的起点是驱动程序，因为这些驱动程序被设计为具有与内核本身相同的权限级别。 在过去，这允许AV和EDR供应商修补内核代码，以便在它们从用户区过渡到内核时检查API调用。 然而，微软推出了内核补丁保护（又称 "PatchGuard"），它阻止了对内核的补丁。


这迫使安全厂商重新评估他们如何进行这些检查。 现在，大多数厂商必须在用户区进行检查，这是通过 "API Hooking "实现的。 有多种方法可以做到这一点--我们将看看 "inline"和  "IAT" hooking.

# IAT Hooking

什么是IAT？

> 导入地址表（IAT）是PE结构中一个相对简单的查找表--它包含一个由PE导入的API函数的列表以及它们在内存中的相关地址。 当PE调用一个API时，它不会在运行时动态地解析它的地址（例如，用GetProcAddress），因为这样做会很费劲。 相反，它从IAT中抓取它。(The Import Address Table (IAT) is a relatively simply lookup table within a PE structure - it contains a list of API functions imported by the PE and their associated addresses in memory.  When a PE calls an API, it does not dynamically resolve its address at runtime (e.g. with GetProcAddress) because that would be costly.  Instead, it grabs it from the IAT.)


使用[CFF Explorer](https://ntcore.com/?page_id=388)打开 MessageBox 应用程序，我们可以查看它的 IAT

1684160298609.jpg

也可以在[WinDbg](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools)查看IAT

1684160364614.jpg


当EDR DLL被注入时，它将浏览IAT并找到任何它想钩住的API。 然后它将简单地把这些API的地址替换为指向它自己内存空间中的迂回函数的地址。 这也可以在WinDbg中看到。 这里我们可以看到地址现在指向IAT！MessageBoxWDetour，而不是原来在user32.dll的地址。

1684160450289.jpg

在执行IAT钩子的时候，迂回方法会改变传递给API调用的字符串。 本例中使用的迂回方法非常简单：(When executed with the IAT hook in place, the detour method changes the strings passed to the API call.  The detour method used for this example is very simple:)

```
EXTERN_C
int
WINAPI
HookMessageBoxW(
  _In_opt_ HWND hWnd,
  _In_opt_ LPCWSTR lpText,
  _In_opt_ LPCWSTR lpCaption,
  _In_ UINT uType)
{
  return OrigMessageBoxW(hWnd, L"Hooked baby", L"HOOKED", uType);
}
```

# Inline Hooking

inline (or detour/trampoline) hooking是通过修补内存中的API调用指令实现的, 当EDR的用户区DLL被注入到一个进程中时，它会解析它想钩住的每个API函数的地址，并在每个函数的开头打上一条jmp指令。 这将把执行流重定向到EDR的DLL内存空间内的一个"detour" 方法， EDR将检查API调用并决定如何处理它。

如果被认为是恶意的，该调用可以直接被阻止。 如果不是，它可以被转发到原始API函数。 它也可能引发警报。

下面是一个MessageBox API在WinDbg中正常情况下出现的例子。 我们可以看到，第一条指令是一个sub命令

1684160989414.jpg

However, when the API is hooked, that instruction is patched with a **jmp**

1684161034506.jpg

# Hook Bypass Strategies

> IAT和inline hooks都可以通过打补丁的方式有效地 "解除钩子"，以恢复它们的原始值。由于这一切都发生在我们控制的进程的用户区，我们可以相对自由地这样做。 在内联钩子的情况下，我们甚至可以从磁盘上重新加载整个模块（例如kernel32.dll, ntdll.dll等），这将把一个全新的副本映射到内存中，消除钩子。(Both IAT and inline hooks can be effectively "unhooked" by patching over them to restore their original values. Since this is all happening in userland of a process we control, we're relatively free to do that.  In the case of inline hooking, we can even reload entire modules from disk (e.g. kernel32.dll, ntdll.dll etc) which would map an entirely fresh copy into memory, erasing the hooks.)

> 这样做的一个相当重要的缺点是，EDR会监控他们自己钩子的完整性。 因此，即使我们解除了钩子，EDR也可以简单地在以后重新钩住它们，而且更重要的是，会发出警报说检测到钩子被篡改了。(One rather significant downside to this, is that EDRs do monitor the integrity of their own hooks.  So even if we did unhook them, the EDR can simply re-hook them at a later date and more significantly, raise an alert that hook tampering was detected.)

> 在我看来，更好的策略是找到不同的方式来执行所需的API，而不去碰钩子。(In my view, a better strategy is to find different ways of executing the desired APIs, without ever touching the hooks.)

