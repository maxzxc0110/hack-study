# Defence in Depth

几种情况可能导致红队把服务用户暴露在危险当中

> Leaving unauthenticated backdoors open and accessible via the Internet, such as web shells or SOCKS proxies.(保留未经身份验证的后门通过 Internet 打开和访问，如 Web shell 或 SOCKS 代理。)

> Using unencrypted channels, such as netcat or HTTP shells.(使用未加密的通道，如 netcat 或 HTTP shell)

> C2 servers being compromised, e.g. this [Cobalt Strike RCE](https://blog.cobaltstrike.com/2016/09/28/cobalt-strike-rce-active-exploitation-reported/) and [Covenant RCE](https://blog.null.farm/hunting-the-hunters).(C2服务器暴露，Cobalt Strike RCE或者Covenant RCE)

# Infrastructure Design

C2基础设施图表

![img](https://rto2-assets.s3.eu-west-2.amazonaws.com/inf/red-team-infra-overview.png?width=1920)

# Apache Installation

安装
```
sudo apt install apache2
sudo a2enmod ssl rewrite proxy proxy_http
```

配置文件
```
ubuntu@redirector-1 /e/a/sites-enabled> ll
total 0
lrwxrwxrwx 1 root root 35 Nov  5  2021 000-default.conf -> ../sites-available/000-default.conf
ubuntu@redirector-1 /e/a/sites-enabled> sudo rm 000-default.conf
ubuntu@redirector-1 /e/a/sites-enabled> sudo ln -s ../sites-available/default-ssl.conf .
ubuntu@redirector-1 /e/a/sites-enabled> ll
total 0
lrwxrwxrwx 1 root root 35 May 26 10:27 default-ssl.conf -> ../sites-available/default-ssl.conf
```

重启apache
```
sudo systemctl restart apache2
```

# Java KeyStore

因为CS是java写的，公钥和私钥都需要引入Java KeyStore

首先，我们需要将单独的公共和私有文件组合成一个 PKCS12文件，需要设置一个密码，此密码后面要用到

```
openssl pkcs12 -inkey private.key -in public.crt -export -out acme.pkcs12
```

然后，可以使用 keytool 实用工具将 PKCS12文件转换为 JavaKeyStore

```
 keytool -importkeystore -srckeystore acme.pkcs12 -srcstoretype pkcs12 -destkeystore acme.store
```

这个新存储的密码可以是相同的，也可以是不同的

Pkcs12文件现在可以删除。在使用新的 JavaKeyStore 之前，需要在C2配置文件中引用它

```
https-certificate {
     set keystore "acme.store";
     set password "password";
}
```

打开teamserver时指定上面配置的profile文件

```
ubuntu@teamserver ~/cobaltstrike> sudo ./teamserver 10.10.0.69 Passw0rd! c2-profiles/normal/webbug_getonly.profile

[*] Checking TeamServerImage for local update

[*] Verifying MD5 Message Digest for TeamServerImage
TeamServerImage: OK

[*] Will use existing X509 certificate and keystore (for SSL)

[*] Starting teamserver
[*] Team Server Version: 4.6.1 (20220511) Licensed
[*] Setting 'https.protocols' system property: SSLv3,SSLv2Hello,TLSv1,TLSv1.1,TLSv1.2,TLSv1.3
[+] I see you're into threat replication. c2-profiles/normal/webbug_getonly.profile loaded.
[+] Team server is up on 0.0.0.0:50050
[*] SHA256 hash of SSL cert is: e08407b2f751572ae7d1f0e8f5b1a01ba874293fd0b37d66d05843d88f1fbfc2
```

# HTTPS Listener for Redirector

配置完ssl证书以后，CS选择payload要注意选择 HTTPS

![img](https://rto2-assets.s3.eu-west-2.amazonaws.com/inf/https-listener-config.png?width=1920&dpr=3)


# SSH Tunnel

ssh远程端口转发,把远程机器上的8443端口流量全部转到本地teamserver 443端口

```
ssh -N -R 8443:localhost:443 -i ssh-user ssh-user@10.10.5.3
```

现在在ubuntu上访问本地8443端口，流量会转到teamserver
```
curl -v -k https://localhost:8443
```

而在ubuntu上是无法直接访问teamserver的443端口的

```
 curl -v -k https://10.10.0.69
```

# autossh

为了方便起见，可以使用[autossh](https://linux.die.net/man/1/autossh) 自动创建和维护这个 SSH 通道

1. 打开配置文件
```
vim .ssh/config
```

2. 添加以下内容
```
Host                 redirector-1
HostName             10.10.5.39
User                 ssh-user
Port                 22
IdentityFile         /home/ubuntu/ssh-user
RemoteForward        8443 localhost:443
ServerAliveInterval  30
ServerAliveCountMax  3
```

3. 执行下面命令

```
autossh -M 0 -f -N redirector-1
```

```-M``` 0 disables the autossh monitoring port (in favour of OpenSSH's built-in ServerAliveInterval and ServerAliveCountMax capabilities).

```-f``` tells autossh to run in the background.


# Enabling htaccess

> 是什么？
.Htaccess 是由 Apache 执行的配置文件

> 为什么？
它可以用于从基本流量重定向，密码保护，图像热链接预防的一切（ It can be used for everything from basic traffic redirection, password protection, to image hot link prevention.）

> 怎么用？

启用htaccess，需要修改```/etc/apache2/sites-enabled/default-ssl.conf```


新加一对<Directory>标签，添加以下内容：

```
<Directory /var/www/html/>
    Options Indexes FollowSymLinks MultiViews
    AllowOverride All
    Require all granted
</Directory>
```

在```SSLEngine on```下面添加```SSLProxyEngine on```

编辑完成以后，重启apache

```
 sudo systemctl restart apache2
```

> 参数解释：

[L] - Last.  Tells mod_rewrite to stop processing further rules.
[NE] - No Escape.  Don't encode special characters (e.g. & and ?) to their hex values.
[P] - Proxy.  Handle the request with mod_proxy.
[R] - Redirect.  Send a redirect code in response.
[S] - Skip.  Skip the next N number of rules.
[T] - Type.  Sets the MIME type of the response.


> 测试

1. 写内容到首页

```
echo "Hello from Apache" | sudo tee /var/www/html/index.html 
```

2. 在/var/www/html创建一个新的.htaccess文件
```
RewriteEngine on
RewriteRule ^test$ index.html [NC]
```

3. 访问一个不存在的页面test，会重定向到自定义输出字符串，因为受到上面.htaccess文件约束


```
ubuntu@redirector-1 ~> curl -k https://localhost/test
Hello from Apache
```

# User Agent Rules

还是上面.Htaccess里的规则讲解，这里是根据浏览器引擎（User Agent）做规则逻辑

比如屏蔽掉一切curl和wget的http请求（一般curl和wget命令默认的浏览器引擎）

```
RewriteEngine on

RewriteCond %{HTTP_USER_AGENT} curl|wget [NC]
RewriteRule .* - [F]
```

此时用curl和wget访问则会返回403状态码


另外一个关于windows的松散的规则，如果访问的User Agent带有"Windows NT 10.0"字样，重定向到https://localhost:8443/win-payload

```
RewriteEngine on

RewriteCond %{HTTP_USER_AGENT} curl|wget [NC]
RewriteRule .* - [F]

RewriteCond %{HTTP_USER_AGENT} "Windows NT 10.0" [NC]
RewriteRule .* https://localhost:8443/win-payload [P]
```

如果我们现在在CS上制作一个payload：```https://localhost/win-payload.exe```

客户端只要以下面命令访问(符合"Windows NT 10.0" 规则),则会重定向到我们上面的payload：

```
curl -k -A "Mozilla/5.0 (Windows NT 10.0; Trident/7.0; rv:11.0) like Gecko" https://localhost/win-payload.exe
```

# Cookie Rules

添加一个带cookie的规则

```
RewriteEngine on

RewriteCond %{HTTP_COOKIE} TestCookie [NC]
RewriteRule .* https://localhost:8443/cookie-test [P]
```

如果此时发送一个带有cookie的请求，则会被重定向到```https://localhost:8443/cookie-test```

```
 curl -k --cookie "TestCookie=Blah" https://localhost 
```

需要注意，由于规则是自上而下处理的，因此我们可以将它们分层以获得更大的整体效果。例如，在顶部放置特定的阻塞规则，在底部放置代理规则。

```
RewriteEngine on

RewriteCond %{HTTP_USER_AGENT} "curl|wget" [NC]
RewriteRule .* - [F]

RewriteCond %{HTTP_COOKIE} "TestCookie" [NC]
RewriteRule .* https://localhost:8443/cookie-test [P]
```

在这种情况下，用户代理规则首先触发，这样即使我们有正确的 cookie 名称，默认的 curl/wget 字符串也会被阻塞


制作一个“允许的”用户代理让它通过。

```
curl -k -A "mozilla" --cookie "TestCookie=Blah" https://localhost
```


