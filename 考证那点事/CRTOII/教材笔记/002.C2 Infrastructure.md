# Defence in Depth

几种情况可能导致红队把服务用户暴露在危险当中

> Leaving unauthenticated backdoors open and accessible via the Internet, such as web shells or SOCKS proxies.(保留未经身份验证的后门通过 Internet 打开和访问，如 Web shell 或 SOCKS 代理。)

> Using unencrypted channels, such as netcat or HTTP shells.(使用未加密的通道，如 netcat 或 HTTP shell)

> C2 servers being compromised, e.g. this [Cobalt Strike RCE](https://blog.cobaltstrike.com/2016/09/28/cobalt-strike-rce-active-exploitation-reported/) and [Covenant RCE](https://blog.null.farm/hunting-the-hunters).(C2服务器暴露，Cobalt Strike RCE或者Covenant RCE)

# Infrastructure Design

C2基础设施图表

![img](https://rto2-assets.s3.eu-west-2.amazonaws.com/inf/red-team-infra-overview.png?width=1920)

# Apache Installation

安装
```
sudo apt install apache2
sudo a2enmod ssl rewrite proxy proxy_http
```

配置文件
```
ubuntu@redirector-1 /e/a/sites-enabled> ll
total 0
lrwxrwxrwx 1 root root 35 Nov  5  2021 000-default.conf -> ../sites-available/000-default.conf
ubuntu@redirector-1 /e/a/sites-enabled> sudo rm 000-default.conf
ubuntu@redirector-1 /e/a/sites-enabled> sudo ln -s ../sites-available/default-ssl.conf .
ubuntu@redirector-1 /e/a/sites-enabled> ll
total 0
lrwxrwxrwx 1 root root 35 May 26 10:27 default-ssl.conf -> ../sites-available/default-ssl.conf
```

重启apache
```
sudo systemctl restart apache2
```

# Java KeyStore

因为CS是java写的，公钥和私钥都需要引入Java KeyStore

首先，我们需要将单独的公共和私有文件组合成一个 PKCS12文件，需要设置一个密码，此密码后面要用到

```
openssl pkcs12 -inkey private.key -in public.crt -export -out acme.pkcs12
```

然后，可以使用 keytool 实用工具将 PKCS12文件转换为 JavaKeyStore

```
 keytool -importkeystore -srckeystore acme.pkcs12 -srcstoretype pkcs12 -destkeystore acme.store
```

这个新存储的密码可以是相同的，也可以是不同的

Pkcs12文件现在可以删除。在使用新的 JavaKeyStore 之前，需要在C2配置文件中引用它

```
https-certificate {
     set keystore "acme.store";
     set password "password";
}
```

打开teamserver时指定上面配置的profile文件

```
ubuntu@teamserver ~/cobaltstrike> sudo ./teamserver 10.10.0.69 Passw0rd! c2-profiles/normal/webbug_getonly.profile

[*] Checking TeamServerImage for local update

[*] Verifying MD5 Message Digest for TeamServerImage
TeamServerImage: OK

[*] Will use existing X509 certificate and keystore (for SSL)

[*] Starting teamserver
[*] Team Server Version: 4.6.1 (20220511) Licensed
[*] Setting 'https.protocols' system property: SSLv3,SSLv2Hello,TLSv1,TLSv1.1,TLSv1.2,TLSv1.3
[+] I see you're into threat replication. c2-profiles/normal/webbug_getonly.profile loaded.
[+] Team server is up on 0.0.0.0:50050
[*] SHA256 hash of SSL cert is: e08407b2f751572ae7d1f0e8f5b1a01ba874293fd0b37d66d05843d88f1fbfc2
```

# HTTPS Listener for Redirector

配置完ssl证书以后，CS选择payload要注意选择 HTTPS

![img](https://rto2-assets.s3.eu-west-2.amazonaws.com/inf/https-listener-config.png?width=1920&dpr=3)


# SSH Tunnel

ssh远程端口转发,把远程机器上的8443端口流量全部转到本地teamserver 443端口

```
ssh -N -R 8443:localhost:443 -i ssh-user ssh-user@10.10.5.3
```

现在在ubuntu上访问本地8443端口，流量会转到teamserver
```
curl -v -k https://localhost:8443
```

而在ubuntu上是无法直接访问teamserver的443端口的

```
 curl -v -k https://10.10.0.69
```

# autossh

为了方便起见，可以使用[autossh](https://linux.die.net/man/1/autossh) 自动创建和维护这个 SSH 通道

1. 打开配置文件
```
vim .ssh/config
```

2. 添加以下内容
```
Host                 redirector-1
HostName             10.10.5.39
User                 ssh-user
Port                 22
IdentityFile         /home/ubuntu/ssh-user
RemoteForward        8443 localhost:443
ServerAliveInterval  30
ServerAliveCountMax  3
```

3. 执行下面命令

```
autossh -M 0 -f -N redirector-1
```

```-M``` 0 disables the autossh monitoring port (in favour of OpenSSH's built-in ServerAliveInterval and ServerAliveCountMax capabilities).

```-f``` tells autossh to run in the background.


# Enabling htaccess

> 是什么？
.Htaccess 是由 Apache 执行的配置文件

> 为什么？
它可以用于从基本流量重定向，密码保护，图像热链接预防的一切（ It can be used for everything from basic traffic redirection, password protection, to image hot link prevention.）

> 怎么用？

启用htaccess，需要修改```/etc/apache2/sites-enabled/default-ssl.conf```


新加一对<Directory>标签，添加以下内容：

```
<Directory /var/www/html/>
    Options Indexes FollowSymLinks MultiViews
    AllowOverride All
    Require all granted
</Directory>
```

在```SSLEngine on```下面添加```SSLProxyEngine on```

编辑完成以后，重启apache

```
 sudo systemctl restart apache2
```

> 参数解释：

[L] - Last.  Tells mod_rewrite to stop processing further rules.
[NE] - No Escape.  Don't encode special characters (e.g. & and ?) to their hex values.
[P] - Proxy.  Handle the request with mod_proxy.
[R] - Redirect.  Send a redirect code in response.
[S] - Skip.  Skip the next N number of rules.
[T] - Type.  Sets the MIME type of the response.


> 测试

1. 写内容到首页

```
echo "Hello from Apache" | sudo tee /var/www/html/index.html 
```

2. 在/var/www/html创建一个新的.htaccess文件
```
RewriteEngine on
RewriteRule ^test$ index.html [NC]
```

3. 访问一个不存在的页面test，会重定向到自定义输出字符串，因为受到上面.htaccess文件约束


```
ubuntu@redirector-1 ~> curl -k https://localhost/test
Hello from Apache
```

# User Agent Rules

还是上面.Htaccess里的规则讲解，这里是根据浏览器引擎（User Agent）做规则逻辑

比如屏蔽掉一切curl和wget的http请求（一般curl和wget命令默认的浏览器引擎）

```
RewriteEngine on

RewriteCond %{HTTP_USER_AGENT} curl|wget [NC]
RewriteRule .* - [F]
```

此时用curl和wget访问则会返回403状态码


另外一个关于windows的松散的规则，如果访问的User Agent带有"Windows NT 10.0"字样，重定向到https://localhost:8443/win-payload

```
RewriteEngine on

RewriteCond %{HTTP_USER_AGENT} curl|wget [NC]
RewriteRule .* - [F]

RewriteCond %{HTTP_USER_AGENT} "Windows NT 10.0" [NC]
RewriteRule .* https://localhost:8443/win-payload [P]
```

如果我们现在在CS上制作一个payload：```https://localhost/win-payload.exe```

客户端只要以下面命令访问(符合"Windows NT 10.0" 规则),则会重定向到我们上面的payload：

```
curl -k -A "Mozilla/5.0 (Windows NT 10.0; Trident/7.0; rv:11.0) like Gecko" https://localhost/win-payload.exe
```

# Cookie Rules

添加一个带cookie的规则

```
RewriteEngine on

RewriteCond %{HTTP_COOKIE} TestCookie [NC]
RewriteRule .* https://localhost:8443/cookie-test [P]
```

如果此时发送一个带有cookie的请求，则会被重定向到```https://localhost:8443/cookie-test```

```
 curl -k --cookie "TestCookie=Blah" https://localhost 
```

需要注意，由于规则是自上而下处理的，因此我们可以将它们分层以获得更大的整体效果。例如，在顶部放置特定的阻塞规则，在底部放置代理规则。

```
RewriteEngine on

RewriteCond %{HTTP_USER_AGENT} "curl|wget" [NC]
RewriteRule .* - [F]

RewriteCond %{HTTP_COOKIE} "TestCookie" [NC]
RewriteRule .* https://localhost:8443/cookie-test [P]
```

在这种情况下，用户代理规则首先触发，这样即使我们有正确的 cookie 名称，默认的 curl/wget 字符串也会被阻塞


制作一个“允许的”用户代理让它通过。

```
curl -k -A "mozilla" --cookie "TestCookie=Blah" https://localhost
```


# URI & Query Rules

```%{REQUEST_URI}``` ：紧随主机 IP/主机名之后的部分


```%{QUERY_STRING}``` ： URI 之后的任何东西，如：http://localhost/index.php?id=1


例子：
```
RewriteEngine on

RewriteCond %{REQUEST_URI} win-payload [NC]
RewriteRule .* https://localhost:8443%{REQUEST_URI} [P]

RewriteCond %{REQUEST_URI} __utm.gif [NC]
RewriteRule .* https://localhost:8443%{REQUEST_URI} [P]
```

第一条规则将允许目标下载托管有效载荷，第二条规则将为C2流量代理URI。
(The first rule will allow the target to download the hosted payload, and the second rule will proxy the URI for the C2 traffic)


使用```webbug_getonly ``` profile：

```/___utm.gif```表示get请求（3个_）

```/__utm.gif```表示post请求（2个_）


 webbug_getonly.profile的http-get设置
 
```
set uri "/___utm.gif";
client {
        parameter "utmac" "UA-2202604-2";
        parameter "utmcn" "1";
        parameter "utmcs" "ISO-8859-1";
        parameter "utmsr" "1280x1024";
        parameter "utmsc" "32-bit";
        parameter "utmul" "en-US";

        metadata {
                base64url;
                prepend "__utma";
                parameter "utmcc";
        }
}
```

在现有的规则下添加另一条RewriteCond规则，将它们变成一个AND条件。 其中请求URI必须包含__utm.gif，并且查询字符串必须符合我们根据C2配置文件所期望的。 我们无法预测utmcc参数值将是什么，因为它是从被破坏的端点上收集的元数据，但我们知道它将总是以__utma开头。
(Adding another RewriteCond rule underneath the existing one turns them into an AND condition.  Where the request URI must contain __utm.gif and the query string must match what we expect as per the C2 profile.  We can't predict what the utmcc parameter value will be since it's metadata collected from on the compromised endpoint, but we do know it will always begin with __utma.)

get的.htaccess解释规则
```
RewriteCond %{REQUEST_URI} __utm.gif [NC]
RewriteCond %{QUERY_STRING} utmac=UA-2202604-2&utmcn=1&utmcs=ISO-8859-1&utmsr=1280x1024&utmsc=32-bit&utmul=en-US&utmcc=__utma [NC]
RewriteRule .* https://localhost:8443%{REQUEST_URI} [P]
```


webbug_getonly.profile的http-post设置

```
set uri "/__utm.gif";                                                                                                                                          
set verb "GET";                                                                                                                                                
client {                                                                                                                                                       
        id {                                                                                                                                                   
                prepend "UA-220";                                                                                                                              
                append "-2";                                                                                                                                   
                parameter "utmac";                                                                                                                             
        }                                                                                                                                                      
                                                                                                                                                               
        parameter "utmcn" "1";                                                                                                                                 
        parameter "utmcs" "ISO-8859-1";                                                                                                                        
        parameter "utmsr" "1280x1024";                                                                                                                         
        parameter "utmsc" "32-bit";                                                                                                                            
        parameter "utmul" "en-US";

        output {
                base64url;
                prepend "__utma"; 
                parameter "utmcc";
        }
}
```

post的.htaccess解释规则

```
RewriteCond %{QUERY_STRING} utmac=UA-220(.*)-2&utmcn=1&utmcs=ISO-8859-1&utmsr=1280x1024&utmsc=32-bit&utmul=en-US&utmcc=__utma [NC]
```


综合get和post的解释规则
```
RewriteEngine on

RewriteCond %{REQUEST_URI} win-payload [NC]
RewriteRule .* https://localhost:8443%{REQUEST_URI} [P]

RewriteCond %{REQUEST_URI} __utm.gif [NC]
RewriteCond %{QUERY_STRING} utmac=UA-2202604-2&utmcn=1&utmcs=ISO-8859-1&utmsr=1280x1024&utmsc=32-bit&utmul=en-US&utmcc=__utma [NC,OR]
RewriteCond %{QUERY_STRING} utmac=UA-220(.*)-2&utmcn=1&utmcs=ISO-8859-1&utmsr=1280x1024&utmsc=32-bit&utmul=en-US&utmcc=__utma [NC]                                                                       
RewriteRule .* https://localhost:8443%{REQUEST_URI} [P]

RewriteRule .* - [F]
```

这一切设置是为了保护对我们TeamServer服务器的访问。 我们只希望HTTP流量与已知的C2流量（或有效载荷的下载请求）相匹配，从而击中团队服务器。
(The whole idea behind this is to protect access to our TeamServer.  We only want HTTP traffic hitting the Team Server that matches known C2 traffic (or payload download requests).)


# cs2modrewrite

[cs2modrewrite](https://github.com/threatexpress/cs2modrewrite)是一组 Python 工具，可以为 Apache 和 Nginx 自动生成重写规则


一个全局设置(脚本要求)
```
set useragent "Mozilla/5.0 (Windows NT 10.0; Trident/7.0; rv:11.0) like Gecko";
```

执行
```
python3 cs2modrewrite.py -i ~/cobaltstrike/c2-profiles/normal/webbug_getonly.profile -c https://localhost:8443 -r https://www.google.com/ -o webbug_getonly_htaccess
```

参数解释:

-i is the malleable C2 profile.（C2 profile文件）
-c is the location of the Team Server.（teamserver地址）
-r is a URL to redirect "invalid" traffic to.（将“无效”流量重定向到的 URL）
-o is an output file.（输出文件）


现在会生成```webbug_getonly_htaccess```文件，把它放到apache网站目录下

**下面配置可能还需要稍微调整才能正常工作**
```
########################################
## .htaccess START
RewriteEngine On

## (Optional)
## Scripted Web Delivery
## Uncomment and adjust as needed
#RewriteCond %{REQUEST_URI} ^/css/style1.css?$
#RewriteCond %{HTTP_USER_AGENT} ^$
#RewriteRule ^.*$ "http://TEAMSERVER%{REQUEST_URI}" [P,L]

## Default Beacon Staging Support (/1234)
RewriteCond %{{REQUEST_METHOD}} GET [NC]
RewriteCond %{{REQUEST_URI}} ^/..../?$
RewriteCond %{{HTTP_USER_AGENT}} "{ua}"
RewriteRule ^.*$ "{c2server}%{{REQUEST_URI}}" [P,L]

## C2 Traffic (HTTP-GET, HTTP-POST, HTTP-STAGER URIs)
## Logic: If a requested URI AND the User-Agent matches, proxy the connection to the Teamserver
## Consider adding other HTTP checks to fine tune the check.  (HTTP Cookie, HTTP Referer, HTTP Query String, etc)
## Refer to http://httpd.apache.org/docs/current/mod/mod_rewrite.html
## Only allow GET and POST methods to pass to the C2 server
RewriteCond %{REQUEST_METHOD} ^(GET|POST) [NC]
## Profile URIs
RewriteCond %{REQUEST_URI} ^(/___utm.gif.*|/__init.gif.*|/_init.gif.*|/__utm.gif.*)$
## Profile UserAgent
RewriteCond %{HTTP_USER_AGENT} "Mozilla/5.0 \(Windows NT 10.0; Trident/7.0; rv:11.0\) like Gecko"
RewriteRule ^.*$ "https://localhost:8443%{REQUEST_URI}" [P,L]

## Redirect all other traffic here
RewriteRule ^.*$ https://www.google.com//? [L,R=302]

## .htaccess END
########################################
```


# C2 Resiliency

狡兔三窟。为了避免ip被封杀掉以后无beacon可用，可以用ssh开一个远程端口转发，然后把IP加到listener里的hosts field

1683331578688.jpg


host rotation strategy解释：

round-robin:  use each host (top-to-bottom) in a loop.（在循环中使用每个主机(从上到下)）
random:  select a random host each time.（ 每次选择一个随机的主机）
failover:  use a host until the consecutive failover count is reached, then move onto the next.（使用主机直到达到连续的故障转移计数，然后转移到下一个）
rotate:  use each host for the specified length of time, then move onto the next.（在指定的时间内使用每个主机，然后转移到下一个主机）


# Beacon Staging

Cobalt Strike is capable of generating both staged and stageless payloads（CS也可以生成分段和不分段payload）

可以在以下操作路径找到设置

Attacks > Packages > Payload Generator 

Attacks > Packages > Windows Executable

多数情况下不使用分段（staged）payload，因为是 bad OPSEC，但是CS仍然有这个选项：
（ For the most part, we don't use staged payloads because they have quite bad OPSEC, but the Cobalt Strike team server still supports this staging process by default）


x86 and x64 的stagers设置

```
http-stager {
        set uri_x86 "/_init.gif";
        set uri_x64 "/__init.gif";
        ...
}
```


读取shell payload，使用[CobaltStrikeParser](https://github.com/Sentinel-One/CobaltStrikeParser)

```
ubuntu@teamserver ~> python3 CobaltStrikeParser/parse_beacon_config.py shellcode.bin
BeaconType                       - HTTPS
Port                             - 443
SleepTime                        - 5000
MaxGetSize                       - 1048616
Jitter                           - 0
MaxDNS                           - Not Found
PublicKey_MD5                    - c8b0b9d814ec7139ad7b8462c4047ff0
C2Server                         - 10.10.5.39,/___utm.gif,10.10.5.246,/___utm.gif
UserAgent                        - Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; MALC)
HttpPostUri                      - /__utm.gif
Malleable_C2_Instructions        - Remove 15 bytes from the beginning
                                   Remove 15 bytes from the beginning
                                   Remove 10 bytes from the beginning
HttpGet_Metadata                 - ConstParams
                                        utmac=UA-2202604-2
                                        utmcn=1
                                        utmcs=ISO-8859-1
                                        utmsr=1280x1024
                                        utmsc=32-bit
                                        utmul=en-US
                                   Metadata
                                        base64url
                                        prepend "__utma"
                                        parameter "utmcc"
```

这将为防守方提供大量的信息，例如，它将披露你所有的重定向器IP或域、流量概况和后期配置。
(For instance, it would disclose all of your redirector IPs or domains, traffic profile and post-ex configuration.)

最安全的做法是在profile完全禁用他们
```
set host_stage "false";
```


# External C2


Cobalt Strike 支持第三方命令和控制，允许外部组件作为 Team Server 和 Beacon 有效载荷之间的通信层

一些封装好的库

[Python](https://github.com/Und3rf10w/external_c2_framework)

[.NET](https://github.com/rasta-mouse/ExternalC2.NET)

[C++](https://github.com/outflanknl/external_c2)